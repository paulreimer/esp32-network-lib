// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NETWORKMANAGER_NETWORKMANAGER_H_
#define FLATBUFFERS_GENERATED_NETWORKMANAGER_NETWORKMANAGER_H_

#include "flatbuffers/flatbuffers.h"

namespace NetworkManager {

struct WifiConfiguration;

struct NTPConfiguration;

struct NetworkCheckConfiguration;

struct mDNSTXTRecord;

struct mDNSService;

struct mDNSConfiguration;

struct NetworkConnectionIntent;

inline const flatbuffers::TypeTable *WifiConfigurationTypeTable();

inline const flatbuffers::TypeTable *NTPConfigurationTypeTable();

inline const flatbuffers::TypeTable *NetworkCheckConfigurationTypeTable();

inline const flatbuffers::TypeTable *mDNSTXTRecordTypeTable();

inline const flatbuffers::TypeTable *mDNSServiceTypeTable();

inline const flatbuffers::TypeTable *mDNSConfigurationTypeTable();

inline const flatbuffers::TypeTable *NetworkConnectionIntentTypeTable();

struct WifiConfiguration FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return WifiConfigurationTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "NetworkManager.WifiConfiguration";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SSID = 4,
    VT_PASSWORD = 6
  };
  const flatbuffers::String *ssid() const {
    return GetPointer<const flatbuffers::String *>(VT_SSID);
  }
  flatbuffers::String *mutable_ssid() {
    return GetPointer<flatbuffers::String *>(VT_SSID);
  }
  const flatbuffers::String *password() const {
    return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
  }
  flatbuffers::String *mutable_password() {
    return GetPointer<flatbuffers::String *>(VT_PASSWORD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SSID) &&
           verifier.VerifyString(ssid()) &&
           VerifyOffset(verifier, VT_PASSWORD) &&
           verifier.VerifyString(password()) &&
           verifier.EndTable();
  }
};

struct WifiConfigurationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ssid(flatbuffers::Offset<flatbuffers::String> ssid) {
    fbb_.AddOffset(WifiConfiguration::VT_SSID, ssid);
  }
  void add_password(flatbuffers::Offset<flatbuffers::String> password) {
    fbb_.AddOffset(WifiConfiguration::VT_PASSWORD, password);
  }
  explicit WifiConfigurationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WifiConfigurationBuilder &operator=(const WifiConfigurationBuilder &);
  flatbuffers::Offset<WifiConfiguration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WifiConfiguration>(end);
    return o;
  }
};

inline flatbuffers::Offset<WifiConfiguration> CreateWifiConfiguration(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ssid = 0,
    flatbuffers::Offset<flatbuffers::String> password = 0) {
  WifiConfigurationBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_ssid(ssid);
  return builder_.Finish();
}

inline flatbuffers::Offset<WifiConfiguration> CreateWifiConfigurationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ssid = nullptr,
    const char *password = nullptr) {
  auto ssid__ = ssid ? _fbb.CreateString(ssid) : 0;
  auto password__ = password ? _fbb.CreateString(password) : 0;
  return NetworkManager::CreateWifiConfiguration(
      _fbb,
      ssid__,
      password__);
}

struct NTPConfiguration FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NTPConfigurationTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "NetworkManager.NTPConfiguration";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NTP_SERVER = 4,
    VT_POSIX_TIMEZONE = 6
  };
  const flatbuffers::String *ntp_server() const {
    return GetPointer<const flatbuffers::String *>(VT_NTP_SERVER);
  }
  flatbuffers::String *mutable_ntp_server() {
    return GetPointer<flatbuffers::String *>(VT_NTP_SERVER);
  }
  const flatbuffers::String *posix_timezone() const {
    return GetPointer<const flatbuffers::String *>(VT_POSIX_TIMEZONE);
  }
  flatbuffers::String *mutable_posix_timezone() {
    return GetPointer<flatbuffers::String *>(VT_POSIX_TIMEZONE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NTP_SERVER) &&
           verifier.VerifyString(ntp_server()) &&
           VerifyOffset(verifier, VT_POSIX_TIMEZONE) &&
           verifier.VerifyString(posix_timezone()) &&
           verifier.EndTable();
  }
};

struct NTPConfigurationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ntp_server(flatbuffers::Offset<flatbuffers::String> ntp_server) {
    fbb_.AddOffset(NTPConfiguration::VT_NTP_SERVER, ntp_server);
  }
  void add_posix_timezone(flatbuffers::Offset<flatbuffers::String> posix_timezone) {
    fbb_.AddOffset(NTPConfiguration::VT_POSIX_TIMEZONE, posix_timezone);
  }
  explicit NTPConfigurationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NTPConfigurationBuilder &operator=(const NTPConfigurationBuilder &);
  flatbuffers::Offset<NTPConfiguration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NTPConfiguration>(end);
    return o;
  }
};

inline flatbuffers::Offset<NTPConfiguration> CreateNTPConfiguration(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ntp_server = 0,
    flatbuffers::Offset<flatbuffers::String> posix_timezone = 0) {
  NTPConfigurationBuilder builder_(_fbb);
  builder_.add_posix_timezone(posix_timezone);
  builder_.add_ntp_server(ntp_server);
  return builder_.Finish();
}

inline flatbuffers::Offset<NTPConfiguration> CreateNTPConfigurationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *ntp_server = nullptr,
    const char *posix_timezone = nullptr) {
  auto ntp_server__ = ntp_server ? _fbb.CreateString(ntp_server) : 0;
  auto posix_timezone__ = posix_timezone ? _fbb.CreateString(posix_timezone) : 0;
  return NetworkManager::CreateNTPConfiguration(
      _fbb,
      ntp_server__,
      posix_timezone__);
}

struct NetworkCheckConfiguration FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NetworkCheckConfigurationTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "NetworkManager.NetworkCheckConfiguration";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UPSTREAM_PING_IP = 4
  };
  uint32_t upstream_ping_ip() const {
    return GetField<uint32_t>(VT_UPSTREAM_PING_IP, 0);
  }
  bool mutate_upstream_ping_ip(uint32_t _upstream_ping_ip) {
    return SetField<uint32_t>(VT_UPSTREAM_PING_IP, _upstream_ping_ip, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_UPSTREAM_PING_IP) &&
           verifier.EndTable();
  }
};

struct NetworkCheckConfigurationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_upstream_ping_ip(uint32_t upstream_ping_ip) {
    fbb_.AddElement<uint32_t>(NetworkCheckConfiguration::VT_UPSTREAM_PING_IP, upstream_ping_ip, 0);
  }
  explicit NetworkCheckConfigurationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NetworkCheckConfigurationBuilder &operator=(const NetworkCheckConfigurationBuilder &);
  flatbuffers::Offset<NetworkCheckConfiguration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NetworkCheckConfiguration>(end);
    return o;
  }
};

inline flatbuffers::Offset<NetworkCheckConfiguration> CreateNetworkCheckConfiguration(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t upstream_ping_ip = 0) {
  NetworkCheckConfigurationBuilder builder_(_fbb);
  builder_.add_upstream_ping_ip(upstream_ping_ip);
  return builder_.Finish();
}

struct mDNSTXTRecord FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return mDNSTXTRecordTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "NetworkManager.mDNSTXTRecord";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_K = 4,
    VT_V = 6
  };
  const flatbuffers::String *k() const {
    return GetPointer<const flatbuffers::String *>(VT_K);
  }
  flatbuffers::String *mutable_k() {
    return GetPointer<flatbuffers::String *>(VT_K);
  }
  const flatbuffers::String *v() const {
    return GetPointer<const flatbuffers::String *>(VT_V);
  }
  flatbuffers::String *mutable_v() {
    return GetPointer<flatbuffers::String *>(VT_V);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_K) &&
           verifier.VerifyString(k()) &&
           VerifyOffset(verifier, VT_V) &&
           verifier.VerifyString(v()) &&
           verifier.EndTable();
  }
};

struct mDNSTXTRecordBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_k(flatbuffers::Offset<flatbuffers::String> k) {
    fbb_.AddOffset(mDNSTXTRecord::VT_K, k);
  }
  void add_v(flatbuffers::Offset<flatbuffers::String> v) {
    fbb_.AddOffset(mDNSTXTRecord::VT_V, v);
  }
  explicit mDNSTXTRecordBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  mDNSTXTRecordBuilder &operator=(const mDNSTXTRecordBuilder &);
  flatbuffers::Offset<mDNSTXTRecord> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<mDNSTXTRecord>(end);
    return o;
  }
};

inline flatbuffers::Offset<mDNSTXTRecord> CreatemDNSTXTRecord(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> k = 0,
    flatbuffers::Offset<flatbuffers::String> v = 0) {
  mDNSTXTRecordBuilder builder_(_fbb);
  builder_.add_v(v);
  builder_.add_k(k);
  return builder_.Finish();
}

inline flatbuffers::Offset<mDNSTXTRecord> CreatemDNSTXTRecordDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *k = nullptr,
    const char *v = nullptr) {
  auto k__ = k ? _fbb.CreateString(k) : 0;
  auto v__ = v ? _fbb.CreateString(v) : 0;
  return NetworkManager::CreatemDNSTXTRecord(
      _fbb,
      k__,
      v__);
}

struct mDNSService FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return mDNSServiceTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "NetworkManager.mDNSService";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTANCE = 4,
    VT_NAME = 6,
    VT_PROTOCOL = 8,
    VT_PORT = 10,
    VT_TXT_RECORDS = 12
  };
  const flatbuffers::String *instance() const {
    return GetPointer<const flatbuffers::String *>(VT_INSTANCE);
  }
  flatbuffers::String *mutable_instance() {
    return GetPointer<flatbuffers::String *>(VT_INSTANCE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  flatbuffers::String *mutable_protocol() {
    return GetPointer<flatbuffers::String *>(VT_PROTOCOL);
  }
  uint16_t port() const {
    return GetField<uint16_t>(VT_PORT, 0);
  }
  bool mutate_port(uint16_t _port) {
    return SetField<uint16_t>(VT_PORT, _port, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<mDNSTXTRecord>> *txt_records() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mDNSTXTRecord>> *>(VT_TXT_RECORDS);
  }
  flatbuffers::Vector<flatbuffers::Offset<mDNSTXTRecord>> *mutable_txt_records() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<mDNSTXTRecord>> *>(VT_TXT_RECORDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INSTANCE) &&
           verifier.VerifyString(instance()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.VerifyString(protocol()) &&
           VerifyField<uint16_t>(verifier, VT_PORT) &&
           VerifyOffset(verifier, VT_TXT_RECORDS) &&
           verifier.VerifyVector(txt_records()) &&
           verifier.VerifyVectorOfTables(txt_records()) &&
           verifier.EndTable();
  }
};

struct mDNSServiceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_instance(flatbuffers::Offset<flatbuffers::String> instance) {
    fbb_.AddOffset(mDNSService::VT_INSTANCE, instance);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(mDNSService::VT_NAME, name);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(mDNSService::VT_PROTOCOL, protocol);
  }
  void add_port(uint16_t port) {
    fbb_.AddElement<uint16_t>(mDNSService::VT_PORT, port, 0);
  }
  void add_txt_records(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mDNSTXTRecord>>> txt_records) {
    fbb_.AddOffset(mDNSService::VT_TXT_RECORDS, txt_records);
  }
  explicit mDNSServiceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  mDNSServiceBuilder &operator=(const mDNSServiceBuilder &);
  flatbuffers::Offset<mDNSService> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<mDNSService>(end);
    return o;
  }
};

inline flatbuffers::Offset<mDNSService> CreatemDNSService(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> instance = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    uint16_t port = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mDNSTXTRecord>>> txt_records = 0) {
  mDNSServiceBuilder builder_(_fbb);
  builder_.add_txt_records(txt_records);
  builder_.add_protocol(protocol);
  builder_.add_name(name);
  builder_.add_instance(instance);
  builder_.add_port(port);
  return builder_.Finish();
}

inline flatbuffers::Offset<mDNSService> CreatemDNSServiceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *instance = nullptr,
    const char *name = nullptr,
    const char *protocol = nullptr,
    uint16_t port = 0,
    const std::vector<flatbuffers::Offset<mDNSTXTRecord>> *txt_records = nullptr) {
  auto instance__ = instance ? _fbb.CreateString(instance) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto protocol__ = protocol ? _fbb.CreateString(protocol) : 0;
  auto txt_records__ = txt_records ? _fbb.CreateVector<flatbuffers::Offset<mDNSTXTRecord>>(*txt_records) : 0;
  return NetworkManager::CreatemDNSService(
      _fbb,
      instance__,
      name__,
      protocol__,
      port,
      txt_records__);
}

struct mDNSConfiguration FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return mDNSConfigurationTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "NetworkManager.mDNSConfiguration";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HOSTNAME = 4,
    VT_INSTANCE = 6,
    VT_DOMAIN = 8,
    VT_SERVICES = 10
  };
  const flatbuffers::String *hostname() const {
    return GetPointer<const flatbuffers::String *>(VT_HOSTNAME);
  }
  flatbuffers::String *mutable_hostname() {
    return GetPointer<flatbuffers::String *>(VT_HOSTNAME);
  }
  const flatbuffers::String *instance() const {
    return GetPointer<const flatbuffers::String *>(VT_INSTANCE);
  }
  flatbuffers::String *mutable_instance() {
    return GetPointer<flatbuffers::String *>(VT_INSTANCE);
  }
  const flatbuffers::String *domain() const {
    return GetPointer<const flatbuffers::String *>(VT_DOMAIN);
  }
  flatbuffers::String *mutable_domain() {
    return GetPointer<flatbuffers::String *>(VT_DOMAIN);
  }
  const flatbuffers::Vector<flatbuffers::Offset<mDNSService>> *services() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mDNSService>> *>(VT_SERVICES);
  }
  flatbuffers::Vector<flatbuffers::Offset<mDNSService>> *mutable_services() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<mDNSService>> *>(VT_SERVICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HOSTNAME) &&
           verifier.VerifyString(hostname()) &&
           VerifyOffset(verifier, VT_INSTANCE) &&
           verifier.VerifyString(instance()) &&
           VerifyOffset(verifier, VT_DOMAIN) &&
           verifier.VerifyString(domain()) &&
           VerifyOffset(verifier, VT_SERVICES) &&
           verifier.VerifyVector(services()) &&
           verifier.VerifyVectorOfTables(services()) &&
           verifier.EndTable();
  }
};

struct mDNSConfigurationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hostname(flatbuffers::Offset<flatbuffers::String> hostname) {
    fbb_.AddOffset(mDNSConfiguration::VT_HOSTNAME, hostname);
  }
  void add_instance(flatbuffers::Offset<flatbuffers::String> instance) {
    fbb_.AddOffset(mDNSConfiguration::VT_INSTANCE, instance);
  }
  void add_domain(flatbuffers::Offset<flatbuffers::String> domain) {
    fbb_.AddOffset(mDNSConfiguration::VT_DOMAIN, domain);
  }
  void add_services(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mDNSService>>> services) {
    fbb_.AddOffset(mDNSConfiguration::VT_SERVICES, services);
  }
  explicit mDNSConfigurationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  mDNSConfigurationBuilder &operator=(const mDNSConfigurationBuilder &);
  flatbuffers::Offset<mDNSConfiguration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<mDNSConfiguration>(end);
    return o;
  }
};

inline flatbuffers::Offset<mDNSConfiguration> CreatemDNSConfiguration(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> hostname = 0,
    flatbuffers::Offset<flatbuffers::String> instance = 0,
    flatbuffers::Offset<flatbuffers::String> domain = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mDNSService>>> services = 0) {
  mDNSConfigurationBuilder builder_(_fbb);
  builder_.add_services(services);
  builder_.add_domain(domain);
  builder_.add_instance(instance);
  builder_.add_hostname(hostname);
  return builder_.Finish();
}

inline flatbuffers::Offset<mDNSConfiguration> CreatemDNSConfigurationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *hostname = nullptr,
    const char *instance = nullptr,
    const char *domain = nullptr,
    const std::vector<flatbuffers::Offset<mDNSService>> *services = nullptr) {
  auto hostname__ = hostname ? _fbb.CreateString(hostname) : 0;
  auto instance__ = instance ? _fbb.CreateString(instance) : 0;
  auto domain__ = domain ? _fbb.CreateString(domain) : 0;
  auto services__ = services ? _fbb.CreateVector<flatbuffers::Offset<mDNSService>>(*services) : 0;
  return NetworkManager::CreatemDNSConfiguration(
      _fbb,
      hostname__,
      instance__,
      domain__,
      services__);
}

struct NetworkConnectionIntent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return NetworkConnectionIntentTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "NetworkManager.NetworkConnectionIntent";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIFI = 4,
    VT_NTP = 6,
    VT_NETWORK_CHECK = 8,
    VT_MDNS = 10
  };
  const WifiConfiguration *wifi() const {
    return GetPointer<const WifiConfiguration *>(VT_WIFI);
  }
  WifiConfiguration *mutable_wifi() {
    return GetPointer<WifiConfiguration *>(VT_WIFI);
  }
  const NTPConfiguration *ntp() const {
    return GetPointer<const NTPConfiguration *>(VT_NTP);
  }
  NTPConfiguration *mutable_ntp() {
    return GetPointer<NTPConfiguration *>(VT_NTP);
  }
  const NetworkCheckConfiguration *network_check() const {
    return GetPointer<const NetworkCheckConfiguration *>(VT_NETWORK_CHECK);
  }
  NetworkCheckConfiguration *mutable_network_check() {
    return GetPointer<NetworkCheckConfiguration *>(VT_NETWORK_CHECK);
  }
  const mDNSConfiguration *mdns() const {
    return GetPointer<const mDNSConfiguration *>(VT_MDNS);
  }
  mDNSConfiguration *mutable_mdns() {
    return GetPointer<mDNSConfiguration *>(VT_MDNS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WIFI) &&
           verifier.VerifyTable(wifi()) &&
           VerifyOffset(verifier, VT_NTP) &&
           verifier.VerifyTable(ntp()) &&
           VerifyOffset(verifier, VT_NETWORK_CHECK) &&
           verifier.VerifyTable(network_check()) &&
           VerifyOffset(verifier, VT_MDNS) &&
           verifier.VerifyTable(mdns()) &&
           verifier.EndTable();
  }
};

struct NetworkConnectionIntentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_wifi(flatbuffers::Offset<WifiConfiguration> wifi) {
    fbb_.AddOffset(NetworkConnectionIntent::VT_WIFI, wifi);
  }
  void add_ntp(flatbuffers::Offset<NTPConfiguration> ntp) {
    fbb_.AddOffset(NetworkConnectionIntent::VT_NTP, ntp);
  }
  void add_network_check(flatbuffers::Offset<NetworkCheckConfiguration> network_check) {
    fbb_.AddOffset(NetworkConnectionIntent::VT_NETWORK_CHECK, network_check);
  }
  void add_mdns(flatbuffers::Offset<mDNSConfiguration> mdns) {
    fbb_.AddOffset(NetworkConnectionIntent::VT_MDNS, mdns);
  }
  explicit NetworkConnectionIntentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NetworkConnectionIntentBuilder &operator=(const NetworkConnectionIntentBuilder &);
  flatbuffers::Offset<NetworkConnectionIntent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NetworkConnectionIntent>(end);
    return o;
  }
};

inline flatbuffers::Offset<NetworkConnectionIntent> CreateNetworkConnectionIntent(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<WifiConfiguration> wifi = 0,
    flatbuffers::Offset<NTPConfiguration> ntp = 0,
    flatbuffers::Offset<NetworkCheckConfiguration> network_check = 0,
    flatbuffers::Offset<mDNSConfiguration> mdns = 0) {
  NetworkConnectionIntentBuilder builder_(_fbb);
  builder_.add_mdns(mdns);
  builder_.add_network_check(network_check);
  builder_.add_ntp(ntp);
  builder_.add_wifi(wifi);
  return builder_.Finish();
}

inline const flatbuffers::TypeTable *WifiConfigurationTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "ssid",
    "password"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NTPConfigurationTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "ntp_server",
    "posix_timezone"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NetworkCheckConfigurationTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "upstream_ping_ip"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *mDNSTXTRecordTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "k",
    "v"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *mDNSServiceTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mDNSTXTRecordTypeTable
  };
  static const char * const names[] = {
    "instance",
    "name",
    "protocol",
    "port",
    "txt_records"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *mDNSConfigurationTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    mDNSServiceTypeTable
  };
  static const char * const names[] = {
    "hostname",
    "instance",
    "domain",
    "services"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *NetworkConnectionIntentTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    WifiConfigurationTypeTable,
    NTPConfigurationTypeTable,
    NetworkCheckConfigurationTypeTable,
    mDNSConfigurationTypeTable
  };
  static const char * const names[] = {
    "wifi",
    "ntp",
    "network_check",
    "mdns"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const NetworkManager::NetworkConnectionIntent *GetNetworkConnectionIntent(const void *buf) {
  return flatbuffers::GetRoot<NetworkManager::NetworkConnectionIntent>(buf);
}

inline const NetworkManager::NetworkConnectionIntent *GetSizePrefixedNetworkConnectionIntent(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<NetworkManager::NetworkConnectionIntent>(buf);
}

inline NetworkConnectionIntent *GetMutableNetworkConnectionIntent(void *buf) {
  return flatbuffers::GetMutableRoot<NetworkConnectionIntent>(buf);
}

inline const char *NetworkConnectionIntentIdentifier() {
  return "Netw";
}

inline bool NetworkConnectionIntentBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, NetworkConnectionIntentIdentifier());
}

inline bool VerifyNetworkConnectionIntentBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<NetworkManager::NetworkConnectionIntent>(NetworkConnectionIntentIdentifier());
}

inline bool VerifySizePrefixedNetworkConnectionIntentBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<NetworkManager::NetworkConnectionIntent>(NetworkConnectionIntentIdentifier());
}

inline const char *NetworkConnectionIntentExtension() {
  return "fb";
}

inline void FinishNetworkConnectionIntentBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<NetworkManager::NetworkConnectionIntent> root) {
  fbb.Finish(root, NetworkConnectionIntentIdentifier());
}

inline void FinishSizePrefixedNetworkConnectionIntentBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<NetworkManager::NetworkConnectionIntent> root) {
  fbb.FinishSizePrefixed(root, NetworkConnectionIntentIdentifier());
}

}  // namespace NetworkManager

#endif  // FLATBUFFERS_GENERATED_NETWORKMANAGER_NETWORKMANAGER_H_
