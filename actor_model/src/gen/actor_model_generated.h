// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ACTORMODEL_ACTORMODEL_H_
#define FLATBUFFERS_GENERATED_ACTORMODEL_ACTORMODEL_H_

#include "flatbuffers/flatbuffers.h"

#include "uuid_generated.h"

namespace ActorModel {

struct Message;

struct Ok;

struct Error;

struct Unhandled;

struct Signal;

struct Function;

struct Module;

struct MFA;

struct SupervisorFlags;

struct ChildSpec;

struct SupervisorArgs;

struct ProcessExecutionConfig;

inline const flatbuffers::TypeTable *MessageTypeTable();

inline const flatbuffers::TypeTable *OkTypeTable();

inline const flatbuffers::TypeTable *ErrorTypeTable();

inline const flatbuffers::TypeTable *UnhandledTypeTable();

inline const flatbuffers::TypeTable *SignalTypeTable();

inline const flatbuffers::TypeTable *FunctionTypeTable();

inline const flatbuffers::TypeTable *ModuleTypeTable();

inline const flatbuffers::TypeTable *MFATypeTable();

inline const flatbuffers::TypeTable *SupervisorFlagsTypeTable();

inline const flatbuffers::TypeTable *ChildSpecTypeTable();

inline const flatbuffers::TypeTable *SupervisorArgsTypeTable();

inline const flatbuffers::TypeTable *ProcessExecutionConfigTypeTable();

enum class SupervisionStrategy : int8_t {
  one_for_one = 0,
  one_for_all = 1,
  rest_for_one = 2,
  simple_one_for_one = 3,
  MIN = one_for_one,
  MAX = simple_one_for_one
};

inline const SupervisionStrategy (&EnumValuesSupervisionStrategy())[4] {
  static const SupervisionStrategy values[] = {
    SupervisionStrategy::one_for_one,
    SupervisionStrategy::one_for_all,
    SupervisionStrategy::rest_for_one,
    SupervisionStrategy::simple_one_for_one
  };
  return values;
}

inline const char * const *EnumNamesSupervisionStrategy() {
  static const char * const names[] = {
    "one_for_one",
    "one_for_all",
    "rest_for_one",
    "simple_one_for_one",
    nullptr
  };
  return names;
}

inline const char *EnumNameSupervisionStrategy(SupervisionStrategy e) {
  if (e < SupervisionStrategy::one_for_one || e > SupervisionStrategy::simple_one_for_one) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesSupervisionStrategy()[index];
}

enum class ProcessFlag : int16_t {
  trap_exit = 0,
  MIN = trap_exit,
  MAX = trap_exit
};

inline const ProcessFlag (&EnumValuesProcessFlag())[1] {
  static const ProcessFlag values[] = {
    ProcessFlag::trap_exit
  };
  return values;
}

inline const char * const *EnumNamesProcessFlag() {
  static const char * const names[] = {
    "trap_exit",
    nullptr
  };
  return names;
}

inline const char *EnumNameProcessFlag(ProcessFlag e) {
  if (e < ProcessFlag::trap_exit || e > ProcessFlag::trap_exit) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesProcessFlag()[index];
}

enum class EventTerminationAction : int8_t {
  StopProcessing = 0,
  ContinueProcessing = 1,
  MIN = StopProcessing,
  MAX = ContinueProcessing
};

inline const EventTerminationAction (&EnumValuesEventTerminationAction())[2] {
  static const EventTerminationAction values[] = {
    EventTerminationAction::StopProcessing,
    EventTerminationAction::ContinueProcessing
  };
  return values;
}

inline const char * const *EnumNamesEventTerminationAction() {
  static const char * const names[] = {
    "StopProcessing",
    "ContinueProcessing",
    nullptr
  };
  return names;
}

inline const char *EnumNameEventTerminationAction(EventTerminationAction e) {
  if (e < EventTerminationAction::StopProcessing || e > EventTerminationAction::ContinueProcessing) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesEventTerminationAction()[index];
}

enum class Result : uint8_t {
  NONE = 0,
  Ok = 1,
  Error = 2,
  Unhandled = 3,
  MIN = NONE,
  MAX = Unhandled
};

inline const Result (&EnumValuesResult())[4] {
  static const Result values[] = {
    Result::NONE,
    Result::Ok,
    Result::Error,
    Result::Unhandled
  };
  return values;
}

inline const char * const *EnumNamesResult() {
  static const char * const names[] = {
    "NONE",
    "Ok",
    "Error",
    "Unhandled",
    nullptr
  };
  return names;
}

inline const char *EnumNameResult(Result e) {
  if (e < Result::NONE || e > Result::Unhandled) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesResult()[index];
}

template<typename T> struct ResultTraits {
  static const Result enum_value = Result::NONE;
};

template<> struct ResultTraits<Ok> {
  static const Result enum_value = Result::Ok;
};

template<> struct ResultTraits<Error> {
  static const Result enum_value = Result::Error;
};

template<> struct ResultTraits<Unhandled> {
  static const Result enum_value = Result::Unhandled;
};

bool VerifyResult(flatbuffers::Verifier &verifier, const void *obj, Result type);
bool VerifyResultVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class ChildSpecRestartFlag : int8_t {
  permanent = 0,
  temporary = 1,
  transient = 2,
  MIN = permanent,
  MAX = transient
};

inline const ChildSpecRestartFlag (&EnumValuesChildSpecRestartFlag())[3] {
  static const ChildSpecRestartFlag values[] = {
    ChildSpecRestartFlag::permanent,
    ChildSpecRestartFlag::temporary,
    ChildSpecRestartFlag::transient
  };
  return values;
}

inline const char * const *EnumNamesChildSpecRestartFlag() {
  static const char * const names[] = {
    "permanent",
    "temporary",
    "transient",
    nullptr
  };
  return names;
}

inline const char *EnumNameChildSpecRestartFlag(ChildSpecRestartFlag e) {
  if (e < ChildSpecRestartFlag::permanent || e > ChildSpecRestartFlag::transient) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesChildSpecRestartFlag()[index];
}

enum class ChildSpecTypeFlag : int8_t {
  worker = 0,
  supervisor = 1,
  MIN = worker,
  MAX = supervisor
};

inline const ChildSpecTypeFlag (&EnumValuesChildSpecTypeFlag())[2] {
  static const ChildSpecTypeFlag values[] = {
    ChildSpecTypeFlag::worker,
    ChildSpecTypeFlag::supervisor
  };
  return values;
}

inline const char * const *EnumNamesChildSpecTypeFlag() {
  static const char * const names[] = {
    "worker",
    "supervisor",
    nullptr
  };
  return names;
}

inline const char *EnumNameChildSpecTypeFlag(ChildSpecTypeFlag e) {
  if (e < ChildSpecTypeFlag::worker || e > ChildSpecTypeFlag::supervisor) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesChildSpecTypeFlag()[index];
}

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MessageTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ActorModel.Message";
  }
  enum {
    VT_TYPE = 4,
    VT_TIMESTAMP = 6,
    VT_FROM_PID = 8,
    VT_PAYLOAD_ALIGNMENT = 10,
    VT_PAYLOAD = 12
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  flatbuffers::String *mutable_type() {
    return GetPointer<flatbuffers::String *>(VT_TYPE);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool mutate_timestamp(uint64_t _timestamp) {
    return SetField<uint64_t>(VT_TIMESTAMP, _timestamp, 0);
  }
  const UUID::UUID *from_pid() const {
    return GetStruct<const UUID::UUID *>(VT_FROM_PID);
  }
  UUID::UUID *mutable_from_pid() {
    return GetStruct<UUID::UUID *>(VT_FROM_PID);
  }
  uint32_t payload_alignment() const {
    return GetField<uint32_t>(VT_PAYLOAD_ALIGNMENT, 0);
  }
  bool mutate_payload_alignment(uint32_t _payload_alignment) {
    return SetField<uint32_t>(VT_PAYLOAD_ALIGNMENT, _payload_alignment, 0);
  }
  const flatbuffers::Vector<uint8_t> *payload() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PAYLOAD);
  }
  flatbuffers::Vector<uint8_t> *mutable_payload() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_PAYLOAD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP) &&
           VerifyField<UUID::UUID>(verifier, VT_FROM_PID) &&
           VerifyField<uint32_t>(verifier, VT_PAYLOAD_ALIGNMENT) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           verifier.VerifyVector(payload()) &&
           verifier.EndTable();
  }
};

struct MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(Message::VT_TYPE, type);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(Message::VT_TIMESTAMP, timestamp, 0);
  }
  void add_from_pid(const UUID::UUID *from_pid) {
    fbb_.AddStruct(Message::VT_FROM_PID, from_pid);
  }
  void add_payload_alignment(uint32_t payload_alignment) {
    fbb_.AddElement<uint32_t>(Message::VT_PAYLOAD_ALIGNMENT, payload_alignment, 0);
  }
  void add_payload(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> payload) {
    fbb_.AddOffset(Message::VT_PAYLOAD, payload);
  }
  explicit MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageBuilder &operator=(const MessageBuilder &);
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Message>(end);
    fbb_.Required(o, Message::VT_TYPE);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    uint64_t timestamp = 0,
    const UUID::UUID *from_pid = 0,
    uint32_t payload_alignment = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> payload = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_payload(payload);
  builder_.add_payload_alignment(payload_alignment);
  builder_.add_from_pid(from_pid);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Message> CreateMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    uint64_t timestamp = 0,
    const UUID::UUID *from_pid = 0,
    uint32_t payload_alignment = 0,
    const std::vector<uint8_t> *payload = nullptr) {
  return ActorModel::CreateMessage(
      _fbb,
      type ? _fbb.CreateString(type) : 0,
      timestamp,
      from_pid,
      payload_alignment,
      payload ? _fbb.CreateVector<uint8_t>(*payload) : 0);
}

struct Ok FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OkTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ActorModel.Ok";
  }
  enum {
    VT_ID = 4
  };
  const UUID::UUID *id() const {
    return GetStruct<const UUID::UUID *>(VT_ID);
  }
  UUID::UUID *mutable_id() {
    return GetStruct<UUID::UUID *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<UUID::UUID>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct OkBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(const UUID::UUID *id) {
    fbb_.AddStruct(Ok::VT_ID, id);
  }
  explicit OkBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OkBuilder &operator=(const OkBuilder &);
  flatbuffers::Offset<Ok> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Ok>(end);
    return o;
  }
};

inline flatbuffers::Offset<Ok> CreateOk(
    flatbuffers::FlatBufferBuilder &_fbb,
    const UUID::UUID *id = 0) {
  OkBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct Error FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ErrorTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ActorModel.Error";
  }
  enum {
    VT_REASON = 4
  };
  const flatbuffers::String *reason() const {
    return GetPointer<const flatbuffers::String *>(VT_REASON);
  }
  flatbuffers::String *mutable_reason() {
    return GetPointer<flatbuffers::String *>(VT_REASON);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_REASON) &&
           verifier.VerifyString(reason()) &&
           verifier.EndTable();
  }
};

struct ErrorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_reason(flatbuffers::Offset<flatbuffers::String> reason) {
    fbb_.AddOffset(Error::VT_REASON, reason);
  }
  explicit ErrorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ErrorBuilder &operator=(const ErrorBuilder &);
  flatbuffers::Offset<Error> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Error>(end);
    fbb_.Required(o, Error::VT_REASON);
    return o;
  }
};

inline flatbuffers::Offset<Error> CreateError(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> reason = 0) {
  ErrorBuilder builder_(_fbb);
  builder_.add_reason(reason);
  return builder_.Finish();
}

inline flatbuffers::Offset<Error> CreateErrorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *reason = nullptr) {
  return ActorModel::CreateError(
      _fbb,
      reason ? _fbb.CreateString(reason) : 0);
}

struct Unhandled FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return UnhandledTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ActorModel.Unhandled";
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct UnhandledBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit UnhandledBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnhandledBuilder &operator=(const UnhandledBuilder &);
  flatbuffers::Offset<Unhandled> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Unhandled>(end);
    return o;
  }
};

inline flatbuffers::Offset<Unhandled> CreateUnhandled(
    flatbuffers::FlatBufferBuilder &_fbb) {
  UnhandledBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Signal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SignalTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ActorModel.Signal";
  }
  enum {
    VT_FROM_PID = 4,
    VT_REASON = 6
  };
  const UUID::UUID *from_pid() const {
    return GetStruct<const UUID::UUID *>(VT_FROM_PID);
  }
  UUID::UUID *mutable_from_pid() {
    return GetStruct<UUID::UUID *>(VT_FROM_PID);
  }
  const flatbuffers::String *reason() const {
    return GetPointer<const flatbuffers::String *>(VT_REASON);
  }
  flatbuffers::String *mutable_reason() {
    return GetPointer<flatbuffers::String *>(VT_REASON);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<UUID::UUID>(verifier, VT_FROM_PID) &&
           VerifyOffset(verifier, VT_REASON) &&
           verifier.VerifyString(reason()) &&
           verifier.EndTable();
  }
};

struct SignalBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_from_pid(const UUID::UUID *from_pid) {
    fbb_.AddStruct(Signal::VT_FROM_PID, from_pid);
  }
  void add_reason(flatbuffers::Offset<flatbuffers::String> reason) {
    fbb_.AddOffset(Signal::VT_REASON, reason);
  }
  explicit SignalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SignalBuilder &operator=(const SignalBuilder &);
  flatbuffers::Offset<Signal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Signal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Signal> CreateSignal(
    flatbuffers::FlatBufferBuilder &_fbb,
    const UUID::UUID *from_pid = 0,
    flatbuffers::Offset<flatbuffers::String> reason = 0) {
  SignalBuilder builder_(_fbb);
  builder_.add_reason(reason);
  builder_.add_from_pid(from_pid);
  return builder_.Finish();
}

inline flatbuffers::Offset<Signal> CreateSignalDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const UUID::UUID *from_pid = 0,
    const char *reason = nullptr) {
  return ActorModel::CreateSignal(
      _fbb,
      from_pid,
      reason ? _fbb.CreateString(reason) : 0);
}

struct Function FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return FunctionTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ActorModel.Function";
  }
  enum {
    VT_NAME = 4,
    VT_ADDRESS = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  uint64_t address() const {
    return GetField<uint64_t>(VT_ADDRESS, 0);
  }
  bool mutate_address(uint64_t _address) {
    return SetField<uint64_t>(VT_ADDRESS, _address, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint64_t>(verifier, VT_ADDRESS) &&
           verifier.EndTable();
  }
};

struct FunctionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Function::VT_NAME, name);
  }
  void add_address(uint64_t address) {
    fbb_.AddElement<uint64_t>(Function::VT_ADDRESS, address, 0);
  }
  explicit FunctionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FunctionBuilder &operator=(const FunctionBuilder &);
  flatbuffers::Offset<Function> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Function>(end);
    return o;
  }
};

inline flatbuffers::Offset<Function> CreateFunction(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint64_t address = 0) {
  FunctionBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Function> CreateFunctionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint64_t address = 0) {
  return ActorModel::CreateFunction(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      address);
}

struct Module FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ModuleTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ActorModel.Module";
  }
  enum {
    VT_NAME = 4,
    VT_EXPORTS = 6,
    VT_PATH = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Function>> *exports() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Function>> *>(VT_EXPORTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<Function>> *mutable_exports() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Function>> *>(VT_EXPORTS);
  }
  const flatbuffers::String *path() const {
    return GetPointer<const flatbuffers::String *>(VT_PATH);
  }
  flatbuffers::String *mutable_path() {
    return GetPointer<flatbuffers::String *>(VT_PATH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_EXPORTS) &&
           verifier.VerifyVector(exports()) &&
           verifier.VerifyVectorOfTables(exports()) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           verifier.EndTable();
  }
};

struct ModuleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Module::VT_NAME, name);
  }
  void add_exports(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Function>>> exports) {
    fbb_.AddOffset(Module::VT_EXPORTS, exports);
  }
  void add_path(flatbuffers::Offset<flatbuffers::String> path) {
    fbb_.AddOffset(Module::VT_PATH, path);
  }
  explicit ModuleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ModuleBuilder &operator=(const ModuleBuilder &);
  flatbuffers::Offset<Module> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Module>(end);
    return o;
  }
};

inline flatbuffers::Offset<Module> CreateModule(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Function>>> exports = 0,
    flatbuffers::Offset<flatbuffers::String> path = 0) {
  ModuleBuilder builder_(_fbb);
  builder_.add_path(path);
  builder_.add_exports(exports);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Module> CreateModuleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<Function>> *exports = nullptr,
    const char *path = nullptr) {
  return ActorModel::CreateModule(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      exports ? _fbb.CreateVector<flatbuffers::Offset<Function>>(*exports) : 0,
      path ? _fbb.CreateString(path) : 0);
}

struct MFA FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MFATypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ActorModel.MFA";
  }
  enum {
    VT_MODULE_NAME = 4,
    VT_FUNCTION_NAME = 6,
    VT_ARGS = 8
  };
  const flatbuffers::String *module_name() const {
    return GetPointer<const flatbuffers::String *>(VT_MODULE_NAME);
  }
  flatbuffers::String *mutable_module_name() {
    return GetPointer<flatbuffers::String *>(VT_MODULE_NAME);
  }
  const flatbuffers::String *function_name() const {
    return GetPointer<const flatbuffers::String *>(VT_FUNCTION_NAME);
  }
  flatbuffers::String *mutable_function_name() {
    return GetPointer<flatbuffers::String *>(VT_FUNCTION_NAME);
  }
  const flatbuffers::Vector<uint8_t> *args() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ARGS);
  }
  flatbuffers::Vector<uint8_t> *mutable_args() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_ARGS);
  }
  const ActorModel::Message *args_nested_root() const {
    return flatbuffers::GetRoot<ActorModel::Message>(args()->Data());
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MODULE_NAME) &&
           verifier.VerifyString(module_name()) &&
           VerifyOffset(verifier, VT_FUNCTION_NAME) &&
           verifier.VerifyString(function_name()) &&
           VerifyOffset(verifier, VT_ARGS) &&
           verifier.VerifyVector(args()) &&
           verifier.EndTable();
  }
};

struct MFABuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_module_name(flatbuffers::Offset<flatbuffers::String> module_name) {
    fbb_.AddOffset(MFA::VT_MODULE_NAME, module_name);
  }
  void add_function_name(flatbuffers::Offset<flatbuffers::String> function_name) {
    fbb_.AddOffset(MFA::VT_FUNCTION_NAME, function_name);
  }
  void add_args(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> args) {
    fbb_.AddOffset(MFA::VT_ARGS, args);
  }
  explicit MFABuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MFABuilder &operator=(const MFABuilder &);
  flatbuffers::Offset<MFA> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MFA>(end);
    return o;
  }
};

inline flatbuffers::Offset<MFA> CreateMFA(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> module_name = 0,
    flatbuffers::Offset<flatbuffers::String> function_name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> args = 0) {
  MFABuilder builder_(_fbb);
  builder_.add_args(args);
  builder_.add_function_name(function_name);
  builder_.add_module_name(module_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<MFA> CreateMFADirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *module_name = nullptr,
    const char *function_name = nullptr,
    const std::vector<uint8_t> *args = nullptr) {
  return ActorModel::CreateMFA(
      _fbb,
      module_name ? _fbb.CreateString(module_name) : 0,
      function_name ? _fbb.CreateString(function_name) : 0,
      args ? _fbb.CreateVector<uint8_t>(*args) : 0);
}

struct SupervisorFlags FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SupervisorFlagsTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ActorModel.SupervisorFlags";
  }
  enum {
    VT_STRATEGY = 4,
    VT_INTENSITY = 6,
    VT_PERIOD = 8
  };
  SupervisionStrategy strategy() const {
    return static_cast<SupervisionStrategy>(GetField<int8_t>(VT_STRATEGY, 0));
  }
  bool mutate_strategy(SupervisionStrategy _strategy) {
    return SetField<int8_t>(VT_STRATEGY, static_cast<int8_t>(_strategy), 0);
  }
  uint32_t intensity() const {
    return GetField<uint32_t>(VT_INTENSITY, 0);
  }
  bool mutate_intensity(uint32_t _intensity) {
    return SetField<uint32_t>(VT_INTENSITY, _intensity, 0);
  }
  uint32_t period() const {
    return GetField<uint32_t>(VT_PERIOD, 0);
  }
  bool mutate_period(uint32_t _period) {
    return SetField<uint32_t>(VT_PERIOD, _period, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STRATEGY) &&
           VerifyField<uint32_t>(verifier, VT_INTENSITY) &&
           VerifyField<uint32_t>(verifier, VT_PERIOD) &&
           verifier.EndTable();
  }
};

struct SupervisorFlagsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_strategy(SupervisionStrategy strategy) {
    fbb_.AddElement<int8_t>(SupervisorFlags::VT_STRATEGY, static_cast<int8_t>(strategy), 0);
  }
  void add_intensity(uint32_t intensity) {
    fbb_.AddElement<uint32_t>(SupervisorFlags::VT_INTENSITY, intensity, 0);
  }
  void add_period(uint32_t period) {
    fbb_.AddElement<uint32_t>(SupervisorFlags::VT_PERIOD, period, 0);
  }
  explicit SupervisorFlagsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SupervisorFlagsBuilder &operator=(const SupervisorFlagsBuilder &);
  flatbuffers::Offset<SupervisorFlags> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SupervisorFlags>(end);
    return o;
  }
};

inline flatbuffers::Offset<SupervisorFlags> CreateSupervisorFlags(
    flatbuffers::FlatBufferBuilder &_fbb,
    SupervisionStrategy strategy = SupervisionStrategy::one_for_one,
    uint32_t intensity = 0,
    uint32_t period = 0) {
  SupervisorFlagsBuilder builder_(_fbb);
  builder_.add_period(period);
  builder_.add_intensity(intensity);
  builder_.add_strategy(strategy);
  return builder_.Finish();
}

struct ChildSpec FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ChildSpecTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ActorModel.ChildSpec";
  }
  enum {
    VT_ID = 4,
    VT_START = 6,
    VT_RESTART = 8,
    VT_SHUTDOWN = 10,
    VT_TYPE = 12,
    VT_MODULES = 14
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  const MFA *start() const {
    return GetPointer<const MFA *>(VT_START);
  }
  MFA *mutable_start() {
    return GetPointer<MFA *>(VT_START);
  }
  ChildSpecRestartFlag restart() const {
    return static_cast<ChildSpecRestartFlag>(GetField<int8_t>(VT_RESTART, 0));
  }
  bool mutate_restart(ChildSpecRestartFlag _restart) {
    return SetField<int8_t>(VT_RESTART, static_cast<int8_t>(_restart), 0);
  }
  uint32_t shutdown() const {
    return GetField<uint32_t>(VT_SHUTDOWN, 5000);
  }
  bool mutate_shutdown(uint32_t _shutdown) {
    return SetField<uint32_t>(VT_SHUTDOWN, _shutdown, 5000);
  }
  ChildSpecTypeFlag type() const {
    return static_cast<ChildSpecTypeFlag>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool mutate_type(ChildSpecTypeFlag _type) {
    return SetField<int8_t>(VT_TYPE, static_cast<int8_t>(_type), 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Module>> *modules() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Module>> *>(VT_MODULES);
  }
  flatbuffers::Vector<flatbuffers::Offset<Module>> *mutable_modules() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Module>> *>(VT_MODULES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffsetRequired(verifier, VT_START) &&
           verifier.VerifyTable(start()) &&
           VerifyField<int8_t>(verifier, VT_RESTART) &&
           VerifyField<uint32_t>(verifier, VT_SHUTDOWN) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_MODULES) &&
           verifier.VerifyVector(modules()) &&
           verifier.VerifyVectorOfTables(modules()) &&
           verifier.EndTable();
  }
};

struct ChildSpecBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(ChildSpec::VT_ID, id);
  }
  void add_start(flatbuffers::Offset<MFA> start) {
    fbb_.AddOffset(ChildSpec::VT_START, start);
  }
  void add_restart(ChildSpecRestartFlag restart) {
    fbb_.AddElement<int8_t>(ChildSpec::VT_RESTART, static_cast<int8_t>(restart), 0);
  }
  void add_shutdown(uint32_t shutdown) {
    fbb_.AddElement<uint32_t>(ChildSpec::VT_SHUTDOWN, shutdown, 5000);
  }
  void add_type(ChildSpecTypeFlag type) {
    fbb_.AddElement<int8_t>(ChildSpec::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_modules(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Module>>> modules) {
    fbb_.AddOffset(ChildSpec::VT_MODULES, modules);
  }
  explicit ChildSpecBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ChildSpecBuilder &operator=(const ChildSpecBuilder &);
  flatbuffers::Offset<ChildSpec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChildSpec>(end);
    fbb_.Required(o, ChildSpec::VT_ID);
    fbb_.Required(o, ChildSpec::VT_START);
    return o;
  }
};

inline flatbuffers::Offset<ChildSpec> CreateChildSpec(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<MFA> start = 0,
    ChildSpecRestartFlag restart = ChildSpecRestartFlag::permanent,
    uint32_t shutdown = 5000,
    ChildSpecTypeFlag type = ChildSpecTypeFlag::worker,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Module>>> modules = 0) {
  ChildSpecBuilder builder_(_fbb);
  builder_.add_modules(modules);
  builder_.add_shutdown(shutdown);
  builder_.add_start(start);
  builder_.add_id(id);
  builder_.add_type(type);
  builder_.add_restart(restart);
  return builder_.Finish();
}

inline flatbuffers::Offset<ChildSpec> CreateChildSpecDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    flatbuffers::Offset<MFA> start = 0,
    ChildSpecRestartFlag restart = ChildSpecRestartFlag::permanent,
    uint32_t shutdown = 5000,
    ChildSpecTypeFlag type = ChildSpecTypeFlag::worker,
    const std::vector<flatbuffers::Offset<Module>> *modules = nullptr) {
  return ActorModel::CreateChildSpec(
      _fbb,
      id ? _fbb.CreateString(id) : 0,
      start,
      restart,
      shutdown,
      type,
      modules ? _fbb.CreateVector<flatbuffers::Offset<Module>>(*modules) : 0);
}

struct SupervisorArgs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SupervisorArgsTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ActorModel.SupervisorArgs";
  }
  enum {
    VT_CHILD_SPECS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<ChildSpec>> *child_specs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ChildSpec>> *>(VT_CHILD_SPECS);
  }
  flatbuffers::Vector<flatbuffers::Offset<ChildSpec>> *mutable_child_specs() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<ChildSpec>> *>(VT_CHILD_SPECS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHILD_SPECS) &&
           verifier.VerifyVector(child_specs()) &&
           verifier.VerifyVectorOfTables(child_specs()) &&
           verifier.EndTable();
  }
};

struct SupervisorArgsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_child_specs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ChildSpec>>> child_specs) {
    fbb_.AddOffset(SupervisorArgs::VT_CHILD_SPECS, child_specs);
  }
  explicit SupervisorArgsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SupervisorArgsBuilder &operator=(const SupervisorArgsBuilder &);
  flatbuffers::Offset<SupervisorArgs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SupervisorArgs>(end);
    return o;
  }
};

inline flatbuffers::Offset<SupervisorArgs> CreateSupervisorArgs(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ChildSpec>>> child_specs = 0) {
  SupervisorArgsBuilder builder_(_fbb);
  builder_.add_child_specs(child_specs);
  return builder_.Finish();
}

inline flatbuffers::Offset<SupervisorArgs> CreateSupervisorArgsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ChildSpec>> *child_specs = nullptr) {
  return ActorModel::CreateSupervisorArgs(
      _fbb,
      child_specs ? _fbb.CreateVector<flatbuffers::Offset<ChildSpec>>(*child_specs) : 0);
}

struct ProcessExecutionConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ProcessExecutionConfigTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ActorModel.ProcessExecutionConfig";
  }
  enum {
    VT_TASK_PRIO = 4,
    VT_TASK_STACK_SIZE = 6,
    VT_MAILBOX_SIZE = 8,
    VT_SEND_TIMEOUT_MICROSECONDS = 10,
    VT_RECEIVE_TIMEOUT_MICROSECONDS = 12,
    VT_RECEIVE_LOCK_TIMEOUT_MICROSECONDS = 14
  };
  int32_t task_prio() const {
    return GetField<int32_t>(VT_TASK_PRIO, 5);
  }
  bool mutate_task_prio(int32_t _task_prio) {
    return SetField<int32_t>(VT_TASK_PRIO, _task_prio, 5);
  }
  uint32_t task_stack_size() const {
    return GetField<uint32_t>(VT_TASK_STACK_SIZE, 2560);
  }
  bool mutate_task_stack_size(uint32_t _task_stack_size) {
    return SetField<uint32_t>(VT_TASK_STACK_SIZE, _task_stack_size, 2560);
  }
  uint32_t mailbox_size() const {
    return GetField<uint32_t>(VT_MAILBOX_SIZE, 2048);
  }
  bool mutate_mailbox_size(uint32_t _mailbox_size) {
    return SetField<uint32_t>(VT_MAILBOX_SIZE, _mailbox_size, 2048);
  }
  uint32_t send_timeout_microseconds() const {
    return GetField<uint32_t>(VT_SEND_TIMEOUT_MICROSECONDS, 4294967295);
  }
  bool mutate_send_timeout_microseconds(uint32_t _send_timeout_microseconds) {
    return SetField<uint32_t>(VT_SEND_TIMEOUT_MICROSECONDS, _send_timeout_microseconds, 4294967295);
  }
  uint32_t receive_timeout_microseconds() const {
    return GetField<uint32_t>(VT_RECEIVE_TIMEOUT_MICROSECONDS, 4294967295);
  }
  bool mutate_receive_timeout_microseconds(uint32_t _receive_timeout_microseconds) {
    return SetField<uint32_t>(VT_RECEIVE_TIMEOUT_MICROSECONDS, _receive_timeout_microseconds, 4294967295);
  }
  uint32_t receive_lock_timeout_microseconds() const {
    return GetField<uint32_t>(VT_RECEIVE_LOCK_TIMEOUT_MICROSECONDS, 4294967295);
  }
  bool mutate_receive_lock_timeout_microseconds(uint32_t _receive_lock_timeout_microseconds) {
    return SetField<uint32_t>(VT_RECEIVE_LOCK_TIMEOUT_MICROSECONDS, _receive_lock_timeout_microseconds, 4294967295);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TASK_PRIO) &&
           VerifyField<uint32_t>(verifier, VT_TASK_STACK_SIZE) &&
           VerifyField<uint32_t>(verifier, VT_MAILBOX_SIZE) &&
           VerifyField<uint32_t>(verifier, VT_SEND_TIMEOUT_MICROSECONDS) &&
           VerifyField<uint32_t>(verifier, VT_RECEIVE_TIMEOUT_MICROSECONDS) &&
           VerifyField<uint32_t>(verifier, VT_RECEIVE_LOCK_TIMEOUT_MICROSECONDS) &&
           verifier.EndTable();
  }
};

struct ProcessExecutionConfigBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_task_prio(int32_t task_prio) {
    fbb_.AddElement<int32_t>(ProcessExecutionConfig::VT_TASK_PRIO, task_prio, 5);
  }
  void add_task_stack_size(uint32_t task_stack_size) {
    fbb_.AddElement<uint32_t>(ProcessExecutionConfig::VT_TASK_STACK_SIZE, task_stack_size, 2560);
  }
  void add_mailbox_size(uint32_t mailbox_size) {
    fbb_.AddElement<uint32_t>(ProcessExecutionConfig::VT_MAILBOX_SIZE, mailbox_size, 2048);
  }
  void add_send_timeout_microseconds(uint32_t send_timeout_microseconds) {
    fbb_.AddElement<uint32_t>(ProcessExecutionConfig::VT_SEND_TIMEOUT_MICROSECONDS, send_timeout_microseconds, 4294967295);
  }
  void add_receive_timeout_microseconds(uint32_t receive_timeout_microseconds) {
    fbb_.AddElement<uint32_t>(ProcessExecutionConfig::VT_RECEIVE_TIMEOUT_MICROSECONDS, receive_timeout_microseconds, 4294967295);
  }
  void add_receive_lock_timeout_microseconds(uint32_t receive_lock_timeout_microseconds) {
    fbb_.AddElement<uint32_t>(ProcessExecutionConfig::VT_RECEIVE_LOCK_TIMEOUT_MICROSECONDS, receive_lock_timeout_microseconds, 4294967295);
  }
  explicit ProcessExecutionConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProcessExecutionConfigBuilder &operator=(const ProcessExecutionConfigBuilder &);
  flatbuffers::Offset<ProcessExecutionConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProcessExecutionConfig>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProcessExecutionConfig> CreateProcessExecutionConfig(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t task_prio = 5,
    uint32_t task_stack_size = 2560,
    uint32_t mailbox_size = 2048,
    uint32_t send_timeout_microseconds = 4294967295,
    uint32_t receive_timeout_microseconds = 4294967295,
    uint32_t receive_lock_timeout_microseconds = 4294967295) {
  ProcessExecutionConfigBuilder builder_(_fbb);
  builder_.add_receive_lock_timeout_microseconds(receive_lock_timeout_microseconds);
  builder_.add_receive_timeout_microseconds(receive_timeout_microseconds);
  builder_.add_send_timeout_microseconds(send_timeout_microseconds);
  builder_.add_mailbox_size(mailbox_size);
  builder_.add_task_stack_size(task_stack_size);
  builder_.add_task_prio(task_prio);
  return builder_.Finish();
}

inline bool VerifyResult(flatbuffers::Verifier &verifier, const void *obj, Result type) {
  switch (type) {
    case Result::NONE: {
      return true;
    }
    case Result::Ok: {
      auto ptr = reinterpret_cast<const Ok *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Result::Error: {
      auto ptr = reinterpret_cast<const Error *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Result::Unhandled: {
      auto ptr = reinterpret_cast<const Unhandled *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyResultVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyResult(
        verifier,  values->Get(i), types->GetEnum<Result>(i))) {
      return false;
    }
  }
  return true;
}

inline const flatbuffers::TypeTable *SupervisionStrategyTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    SupervisionStrategyTypeTable
  };
  static const char * const names[] = {
    "one_for_one",
    "one_for_all",
    "rest_for_one",
    "simple_one_for_one"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ProcessFlagTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SHORT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ProcessFlagTypeTable
  };
  static const char * const names[] = {
    "trap_exit"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *EventTerminationActionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    EventTerminationActionTypeTable
  };
  static const char * const names[] = {
    "StopProcessing",
    "ContinueProcessing"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ResultTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    OkTypeTable,
    ErrorTypeTable,
    UnhandledTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "Ok",
    "Error",
    "Unhandled"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ChildSpecRestartFlagTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ChildSpecRestartFlagTypeTable
  };
  static const char * const names[] = {
    "permanent",
    "temporary",
    "transient"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ChildSpecTypeFlagTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ChildSpecTypeFlagTypeTable
  };
  static const char * const names[] = {
    "worker",
    "supervisor"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MessageTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UCHAR, 1, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    UUID::UUIDTypeTable
  };
  static const char * const names[] = {
    "type",
    "timestamp",
    "from_pid",
    "payload_alignment",
    "payload"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *OkTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    UUID::UUIDTypeTable
  };
  static const char * const names[] = {
    "id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ErrorTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "reason"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *UnhandledTypeTable() {
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 0, nullptr, nullptr, nullptr, nullptr
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SignalTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    UUID::UUIDTypeTable
  };
  static const char * const names[] = {
    "from_pid",
    "reason"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *FunctionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 }
  };
  static const char * const names[] = {
    "name",
    "address"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ModuleTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    FunctionTypeTable
  };
  static const char * const names[] = {
    "name",
    "exports",
    "path"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MFATypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UCHAR, 1, -1 }
  };
  static const char * const names[] = {
    "module_name",
    "function_name",
    "args"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SupervisorFlagsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    SupervisionStrategyTypeTable
  };
  static const char * const names[] = {
    "strategy",
    "intensity",
    "period"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ChildSpecTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 1, 3 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    MFATypeTable,
    ChildSpecRestartFlagTypeTable,
    ChildSpecTypeFlagTypeTable,
    ModuleTypeTable
  };
  static const char * const names[] = {
    "id",
    "start",
    "restart",
    "shutdown",
    "type",
    "modules"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SupervisorArgsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ChildSpecTypeTable
  };
  static const char * const names[] = {
    "child_specs"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ProcessExecutionConfigTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char * const names[] = {
    "task_prio",
    "task_stack_size",
    "mailbox_size",
    "send_timeout_microseconds",
    "receive_timeout_microseconds",
    "receive_lock_timeout_microseconds"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 6, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const ActorModel::Message *GetMessage(const void *buf) {
  return flatbuffers::GetRoot<ActorModel::Message>(buf);
}

inline const ActorModel::Message *GetSizePrefixedMessage(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<ActorModel::Message>(buf);
}

inline Message *GetMutableMessage(void *buf) {
  return flatbuffers::GetMutableRoot<Message>(buf);
}

inline const char *MessageIdentifier() {
  return "Act!";
}

inline bool MessageBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, MessageIdentifier());
}

inline bool VerifyMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ActorModel::Message>(MessageIdentifier());
}

inline bool VerifySizePrefixedMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ActorModel::Message>(MessageIdentifier());
}

inline void FinishMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ActorModel::Message> root) {
  fbb.Finish(root, MessageIdentifier());
}

inline void FinishSizePrefixedMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ActorModel::Message> root) {
  fbb.FinishSizePrefixed(root, MessageIdentifier());
}

}  // namespace ActorModel

#endif  // FLATBUFFERS_GENERATED_ACTORMODEL_ACTORMODEL_H_
