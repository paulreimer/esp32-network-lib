// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ACTORMODEL_ACTORMODEL_H_
#define FLATBUFFERS_GENERATED_ACTORMODEL_ACTORMODEL_H_

#include "flatbuffers/flatbuffers.h"

#include "uuid_generated.h"

namespace ActorModel {

struct Message;
struct MessageT;

struct Ok;
struct OkT;

struct Error;
struct ErrorT;

struct Signal;
struct SignalT;

struct SupervisorFlags;
struct SupervisorFlagsT;

struct ActorExecutionConfig;
struct ActorExecutionConfigT;

enum class SupervisionStrategy : int8_t {
  one_for_one = 0,
  one_for_all = 1,
  rest_for_one = 2,
  simple_one_for_one = 3,
  MIN = one_for_one,
  MAX = simple_one_for_one
};

inline SupervisionStrategy (&EnumValuesSupervisionStrategy())[4] {
  static SupervisionStrategy values[] = {
    SupervisionStrategy::one_for_one,
    SupervisionStrategy::one_for_all,
    SupervisionStrategy::rest_for_one,
    SupervisionStrategy::simple_one_for_one
  };
  return values;
}

inline const char **EnumNamesSupervisionStrategy() {
  static const char *names[] = {
    "one_for_one",
    "one_for_all",
    "rest_for_one",
    "simple_one_for_one",
    nullptr
  };
  return names;
}

inline const char *EnumNameSupervisionStrategy(SupervisionStrategy e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesSupervisionStrategy()[index];
}

enum class ProcessFlag : int16_t {
  trap_exit = 0,
  MIN = trap_exit,
  MAX = trap_exit
};

inline ProcessFlag (&EnumValuesProcessFlag())[1] {
  static ProcessFlag values[] = {
    ProcessFlag::trap_exit
  };
  return values;
}

inline const char **EnumNamesProcessFlag() {
  static const char *names[] = {
    "trap_exit",
    nullptr
  };
  return names;
}

inline const char *EnumNameProcessFlag(ProcessFlag e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesProcessFlag()[index];
}

enum class Result : uint8_t {
  NONE = 0,
  Ok = 1,
  Error = 2,
  MIN = NONE,
  MAX = Error
};

inline Result (&EnumValuesResult())[3] {
  static Result values[] = {
    Result::NONE,
    Result::Ok,
    Result::Error
  };
  return values;
}

inline const char **EnumNamesResult() {
  static const char *names[] = {
    "NONE",
    "Ok",
    "Error",
    nullptr
  };
  return names;
}

inline const char *EnumNameResult(Result e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesResult()[index];
}

template<typename T> struct ResultTraits {
  static const Result enum_value = Result::NONE;
};

template<> struct ResultTraits<Ok> {
  static const Result enum_value = Result::Ok;
};

template<> struct ResultTraits<Error> {
  static const Result enum_value = Result::Error;
};

struct ResultUnion {
  Result type;
  void *value;

  ResultUnion() : type(Result::NONE), value(nullptr) {}
  ResultUnion(ResultUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Result::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ResultUnion(const ResultUnion &) FLATBUFFERS_NOEXCEPT;
  ResultUnion &operator=(const ResultUnion &u) FLATBUFFERS_NOEXCEPT
    { ResultUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ResultUnion &operator=(ResultUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ResultUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = ResultTraits<typename T::TableType>::enum_value;
    if (type != Result::NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, Result type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  OkT *AsOk() {
    return type == Result::Ok ?
      reinterpret_cast<OkT *>(value) : nullptr;
  }
  const OkT *AsOk() const {
    return type == Result::Ok ?
      reinterpret_cast<const OkT *>(value) : nullptr;
  }
  ErrorT *AsError() {
    return type == Result::Error ?
      reinterpret_cast<ErrorT *>(value) : nullptr;
  }
  const ErrorT *AsError() const {
    return type == Result::Error ?
      reinterpret_cast<const ErrorT *>(value) : nullptr;
  }
};

bool VerifyResult(flatbuffers::Verifier &verifier, const void *obj, Result type);
bool VerifyResultVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct MessageT : public flatbuffers::NativeTable {
  typedef Message TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ActorModel.MessageT";
  }
  std::string type;
  uint64_t timestamp;
  std::unique_ptr<UUID> from_pid;
  uint32_t payload_alignment;
  std::vector<uint8_t> payload;
  MessageT()
      : timestamp(0),
        payload_alignment(0) {
  }
};

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ActorModel.Message";
  }
  enum {
    VT_TYPE = 4,
    VT_TIMESTAMP = 6,
    VT_FROM_PID = 8,
    VT_PAYLOAD_ALIGNMENT = 10,
    VT_PAYLOAD = 12
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  flatbuffers::String *mutable_type() {
    return GetPointer<flatbuffers::String *>(VT_TYPE);
  }
  uint64_t timestamp() const {
    return GetField<uint64_t>(VT_TIMESTAMP, 0);
  }
  bool mutate_timestamp(uint64_t _timestamp) {
    return SetField<uint64_t>(VT_TIMESTAMP, _timestamp, 0);
  }
  const UUID *from_pid() const {
    return GetStruct<const UUID *>(VT_FROM_PID);
  }
  UUID *mutable_from_pid() {
    return GetStruct<UUID *>(VT_FROM_PID);
  }
  uint32_t payload_alignment() const {
    return GetField<uint32_t>(VT_PAYLOAD_ALIGNMENT, 0);
  }
  bool mutate_payload_alignment(uint32_t _payload_alignment) {
    return SetField<uint32_t>(VT_PAYLOAD_ALIGNMENT, _payload_alignment, 0);
  }
  const flatbuffers::Vector<uint8_t> *payload() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PAYLOAD);
  }
  flatbuffers::Vector<uint8_t> *mutable_payload() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_PAYLOAD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.Verify(type()) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP) &&
           VerifyField<UUID>(verifier, VT_FROM_PID) &&
           VerifyField<uint32_t>(verifier, VT_PAYLOAD_ALIGNMENT) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           verifier.Verify(payload()) &&
           verifier.EndTable();
  }
  MessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Message> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(Message::VT_TYPE, type);
  }
  void add_timestamp(uint64_t timestamp) {
    fbb_.AddElement<uint64_t>(Message::VT_TIMESTAMP, timestamp, 0);
  }
  void add_from_pid(const UUID *from_pid) {
    fbb_.AddStruct(Message::VT_FROM_PID, from_pid);
  }
  void add_payload_alignment(uint32_t payload_alignment) {
    fbb_.AddElement<uint32_t>(Message::VT_PAYLOAD_ALIGNMENT, payload_alignment, 0);
  }
  void add_payload(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> payload) {
    fbb_.AddOffset(Message::VT_PAYLOAD, payload);
  }
  explicit MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageBuilder &operator=(const MessageBuilder &);
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    uint64_t timestamp = 0,
    const UUID *from_pid = 0,
    uint32_t payload_alignment = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> payload = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_payload(payload);
  builder_.add_payload_alignment(payload_alignment);
  builder_.add_from_pid(from_pid);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Message> CreateMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    uint64_t timestamp = 0,
    const UUID *from_pid = 0,
    uint32_t payload_alignment = 0,
    const std::vector<uint8_t> *payload = nullptr) {
  return ActorModel::CreateMessage(
      _fbb,
      type ? _fbb.CreateString(type) : 0,
      timestamp,
      from_pid,
      payload_alignment,
      payload ? _fbb.CreateVector<uint8_t>(*payload) : 0);
}

flatbuffers::Offset<Message> CreateMessage(flatbuffers::FlatBufferBuilder &_fbb, const MessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OkT : public flatbuffers::NativeTable {
  typedef Ok TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ActorModel.OkT";
  }
  std::string _;
  OkT() {
  }
};

struct Ok FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OkT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ActorModel.Ok";
  }
  enum {
    VT__ = 4
  };
  const flatbuffers::String *_() const {
    return GetPointer<const flatbuffers::String *>(VT__);
  }
  flatbuffers::String *mutable__() {
    return GetPointer<flatbuffers::String *>(VT__);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT__) &&
           verifier.Verify(_()) &&
           verifier.EndTable();
  }
  OkT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OkT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Ok> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OkT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OkBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add__(flatbuffers::Offset<flatbuffers::String> _) {
    fbb_.AddOffset(Ok::VT__, _);
  }
  explicit OkBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OkBuilder &operator=(const OkBuilder &);
  flatbuffers::Offset<Ok> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Ok>(end);
    return o;
  }
};

inline flatbuffers::Offset<Ok> CreateOk(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> _ = 0) {
  OkBuilder builder_(_fbb);
  builder_.add__(_);
  return builder_.Finish();
}

inline flatbuffers::Offset<Ok> CreateOkDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *_ = nullptr) {
  return ActorModel::CreateOk(
      _fbb,
      _ ? _fbb.CreateString(_) : 0);
}

flatbuffers::Offset<Ok> CreateOk(flatbuffers::FlatBufferBuilder &_fbb, const OkT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ErrorT : public flatbuffers::NativeTable {
  typedef Error TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ActorModel.ErrorT";
  }
  std::string reason;
  ErrorT() {
  }
};

struct Error FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ErrorT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ActorModel.Error";
  }
  enum {
    VT_REASON = 4
  };
  const flatbuffers::String *reason() const {
    return GetPointer<const flatbuffers::String *>(VT_REASON);
  }
  flatbuffers::String *mutable_reason() {
    return GetPointer<flatbuffers::String *>(VT_REASON);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_REASON) &&
           verifier.Verify(reason()) &&
           verifier.EndTable();
  }
  ErrorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ErrorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Error> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ErrorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_reason(flatbuffers::Offset<flatbuffers::String> reason) {
    fbb_.AddOffset(Error::VT_REASON, reason);
  }
  explicit ErrorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ErrorBuilder &operator=(const ErrorBuilder &);
  flatbuffers::Offset<Error> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Error>(end);
    return o;
  }
};

inline flatbuffers::Offset<Error> CreateError(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> reason = 0) {
  ErrorBuilder builder_(_fbb);
  builder_.add_reason(reason);
  return builder_.Finish();
}

inline flatbuffers::Offset<Error> CreateErrorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *reason = nullptr) {
  return ActorModel::CreateError(
      _fbb,
      reason ? _fbb.CreateString(reason) : 0);
}

flatbuffers::Offset<Error> CreateError(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SignalT : public flatbuffers::NativeTable {
  typedef Signal TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ActorModel.SignalT";
  }
  std::unique_ptr<UUID> from_pid;
  std::string reason;
  SignalT() {
  }
};

struct Signal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SignalT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ActorModel.Signal";
  }
  enum {
    VT_FROM_PID = 4,
    VT_REASON = 6
  };
  const UUID *from_pid() const {
    return GetStruct<const UUID *>(VT_FROM_PID);
  }
  UUID *mutable_from_pid() {
    return GetStruct<UUID *>(VT_FROM_PID);
  }
  const flatbuffers::String *reason() const {
    return GetPointer<const flatbuffers::String *>(VT_REASON);
  }
  flatbuffers::String *mutable_reason() {
    return GetPointer<flatbuffers::String *>(VT_REASON);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<UUID>(verifier, VT_FROM_PID) &&
           VerifyOffset(verifier, VT_REASON) &&
           verifier.Verify(reason()) &&
           verifier.EndTable();
  }
  SignalT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SignalT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Signal> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SignalT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SignalBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_from_pid(const UUID *from_pid) {
    fbb_.AddStruct(Signal::VT_FROM_PID, from_pid);
  }
  void add_reason(flatbuffers::Offset<flatbuffers::String> reason) {
    fbb_.AddOffset(Signal::VT_REASON, reason);
  }
  explicit SignalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SignalBuilder &operator=(const SignalBuilder &);
  flatbuffers::Offset<Signal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Signal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Signal> CreateSignal(
    flatbuffers::FlatBufferBuilder &_fbb,
    const UUID *from_pid = 0,
    flatbuffers::Offset<flatbuffers::String> reason = 0) {
  SignalBuilder builder_(_fbb);
  builder_.add_reason(reason);
  builder_.add_from_pid(from_pid);
  return builder_.Finish();
}

inline flatbuffers::Offset<Signal> CreateSignalDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const UUID *from_pid = 0,
    const char *reason = nullptr) {
  return ActorModel::CreateSignal(
      _fbb,
      from_pid,
      reason ? _fbb.CreateString(reason) : 0);
}

flatbuffers::Offset<Signal> CreateSignal(flatbuffers::FlatBufferBuilder &_fbb, const SignalT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SupervisorFlagsT : public flatbuffers::NativeTable {
  typedef SupervisorFlags TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ActorModel.SupervisorFlagsT";
  }
  SupervisionStrategy strategy;
  uint32_t intensity;
  uint32_t period;
  SupervisorFlagsT()
      : strategy(SupervisionStrategy::one_for_one),
        intensity(0),
        period(0) {
  }
};

struct SupervisorFlags FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SupervisorFlagsT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ActorModel.SupervisorFlags";
  }
  enum {
    VT_STRATEGY = 4,
    VT_INTENSITY = 6,
    VT_PERIOD = 8
  };
  SupervisionStrategy strategy() const {
    return static_cast<SupervisionStrategy>(GetField<int8_t>(VT_STRATEGY, 0));
  }
  bool mutate_strategy(SupervisionStrategy _strategy) {
    return SetField<int8_t>(VT_STRATEGY, static_cast<int8_t>(_strategy), 0);
  }
  uint32_t intensity() const {
    return GetField<uint32_t>(VT_INTENSITY, 0);
  }
  bool mutate_intensity(uint32_t _intensity) {
    return SetField<uint32_t>(VT_INTENSITY, _intensity, 0);
  }
  uint32_t period() const {
    return GetField<uint32_t>(VT_PERIOD, 0);
  }
  bool mutate_period(uint32_t _period) {
    return SetField<uint32_t>(VT_PERIOD, _period, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_STRATEGY) &&
           VerifyField<uint32_t>(verifier, VT_INTENSITY) &&
           VerifyField<uint32_t>(verifier, VT_PERIOD) &&
           verifier.EndTable();
  }
  SupervisorFlagsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SupervisorFlagsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SupervisorFlags> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SupervisorFlagsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SupervisorFlagsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_strategy(SupervisionStrategy strategy) {
    fbb_.AddElement<int8_t>(SupervisorFlags::VT_STRATEGY, static_cast<int8_t>(strategy), 0);
  }
  void add_intensity(uint32_t intensity) {
    fbb_.AddElement<uint32_t>(SupervisorFlags::VT_INTENSITY, intensity, 0);
  }
  void add_period(uint32_t period) {
    fbb_.AddElement<uint32_t>(SupervisorFlags::VT_PERIOD, period, 0);
  }
  explicit SupervisorFlagsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SupervisorFlagsBuilder &operator=(const SupervisorFlagsBuilder &);
  flatbuffers::Offset<SupervisorFlags> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SupervisorFlags>(end);
    return o;
  }
};

inline flatbuffers::Offset<SupervisorFlags> CreateSupervisorFlags(
    flatbuffers::FlatBufferBuilder &_fbb,
    SupervisionStrategy strategy = SupervisionStrategy::one_for_one,
    uint32_t intensity = 0,
    uint32_t period = 0) {
  SupervisorFlagsBuilder builder_(_fbb);
  builder_.add_period(period);
  builder_.add_intensity(intensity);
  builder_.add_strategy(strategy);
  return builder_.Finish();
}

flatbuffers::Offset<SupervisorFlags> CreateSupervisorFlags(flatbuffers::FlatBufferBuilder &_fbb, const SupervisorFlagsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ActorExecutionConfigT : public flatbuffers::NativeTable {
  typedef ActorExecutionConfig TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ActorModel.ActorExecutionConfigT";
  }
  int32_t task_prio;
  uint32_t task_stack_size;
  ActorExecutionConfigT()
      : task_prio(5),
        task_stack_size(8192) {
  }
};

struct ActorExecutionConfig FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ActorExecutionConfigT NativeTableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "ActorModel.ActorExecutionConfig";
  }
  enum {
    VT_TASK_PRIO = 4,
    VT_TASK_STACK_SIZE = 6
  };
  int32_t task_prio() const {
    return GetField<int32_t>(VT_TASK_PRIO, 5);
  }
  bool mutate_task_prio(int32_t _task_prio) {
    return SetField<int32_t>(VT_TASK_PRIO, _task_prio, 5);
  }
  uint32_t task_stack_size() const {
    return GetField<uint32_t>(VT_TASK_STACK_SIZE, 8192);
  }
  bool mutate_task_stack_size(uint32_t _task_stack_size) {
    return SetField<uint32_t>(VT_TASK_STACK_SIZE, _task_stack_size, 8192);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TASK_PRIO) &&
           VerifyField<uint32_t>(verifier, VT_TASK_STACK_SIZE) &&
           verifier.EndTable();
  }
  ActorExecutionConfigT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ActorExecutionConfigT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ActorExecutionConfig> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActorExecutionConfigT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ActorExecutionConfigBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_task_prio(int32_t task_prio) {
    fbb_.AddElement<int32_t>(ActorExecutionConfig::VT_TASK_PRIO, task_prio, 5);
  }
  void add_task_stack_size(uint32_t task_stack_size) {
    fbb_.AddElement<uint32_t>(ActorExecutionConfig::VT_TASK_STACK_SIZE, task_stack_size, 8192);
  }
  explicit ActorExecutionConfigBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ActorExecutionConfigBuilder &operator=(const ActorExecutionConfigBuilder &);
  flatbuffers::Offset<ActorExecutionConfig> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ActorExecutionConfig>(end);
    return o;
  }
};

inline flatbuffers::Offset<ActorExecutionConfig> CreateActorExecutionConfig(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t task_prio = 5,
    uint32_t task_stack_size = 8192) {
  ActorExecutionConfigBuilder builder_(_fbb);
  builder_.add_task_stack_size(task_stack_size);
  builder_.add_task_prio(task_prio);
  return builder_.Finish();
}

flatbuffers::Offset<ActorExecutionConfig> CreateActorExecutionConfig(flatbuffers::FlatBufferBuilder &_fbb, const ActorExecutionConfigT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline MessageT *Message::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MessageT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Message::UnPackTo(MessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); if (_e) _o->type = _e->str(); };
  { auto _e = timestamp(); _o->timestamp = _e; };
  { auto _e = from_pid(); if (_e) _o->from_pid = std::unique_ptr<UUID>(new UUID(*_e)); };
  { auto _e = payload_alignment(); _o->payload_alignment = _e; };
  { auto _e = payload(); if (_e) { _o->payload.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->payload[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<Message> Message::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Message> CreateMessage(flatbuffers::FlatBufferBuilder &_fbb, const MessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MessageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type.empty() ? 0 : _fbb.CreateString(_o->type);
  auto _timestamp = _o->timestamp;
  auto _from_pid = _o->from_pid ? _o->from_pid.get() : 0;
  auto _payload_alignment = _o->payload_alignment;
  auto _payload = _o->payload.size() ? _fbb.CreateVector(_o->payload) : 0;
  return ActorModel::CreateMessage(
      _fbb,
      _type,
      _timestamp,
      _from_pid,
      _payload_alignment,
      _payload);
}

inline OkT *Ok::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new OkT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Ok::UnPackTo(OkT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = _(); if (_e) _o->_ = _e->str(); };
}

inline flatbuffers::Offset<Ok> Ok::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OkT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOk(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Ok> CreateOk(flatbuffers::FlatBufferBuilder &_fbb, const OkT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OkT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto __ = _o->_.empty() ? 0 : _fbb.CreateString(_o->_);
  return ActorModel::CreateOk(
      _fbb,
      __);
}

inline ErrorT *Error::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ErrorT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Error::UnPackTo(ErrorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = reason(); if (_e) _o->reason = _e->str(); };
}

inline flatbuffers::Offset<Error> Error::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateError(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Error> CreateError(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ErrorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _reason = _o->reason.empty() ? 0 : _fbb.CreateString(_o->reason);
  return ActorModel::CreateError(
      _fbb,
      _reason);
}

inline SignalT *Signal::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SignalT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Signal::UnPackTo(SignalT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = from_pid(); if (_e) _o->from_pid = std::unique_ptr<UUID>(new UUID(*_e)); };
  { auto _e = reason(); if (_e) _o->reason = _e->str(); };
}

inline flatbuffers::Offset<Signal> Signal::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SignalT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSignal(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Signal> CreateSignal(flatbuffers::FlatBufferBuilder &_fbb, const SignalT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SignalT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _from_pid = _o->from_pid ? _o->from_pid.get() : 0;
  auto _reason = _o->reason.empty() ? 0 : _fbb.CreateString(_o->reason);
  return ActorModel::CreateSignal(
      _fbb,
      _from_pid,
      _reason);
}

inline SupervisorFlagsT *SupervisorFlags::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SupervisorFlagsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SupervisorFlags::UnPackTo(SupervisorFlagsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = strategy(); _o->strategy = _e; };
  { auto _e = intensity(); _o->intensity = _e; };
  { auto _e = period(); _o->period = _e; };
}

inline flatbuffers::Offset<SupervisorFlags> SupervisorFlags::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SupervisorFlagsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSupervisorFlags(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SupervisorFlags> CreateSupervisorFlags(flatbuffers::FlatBufferBuilder &_fbb, const SupervisorFlagsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SupervisorFlagsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _strategy = _o->strategy;
  auto _intensity = _o->intensity;
  auto _period = _o->period;
  return ActorModel::CreateSupervisorFlags(
      _fbb,
      _strategy,
      _intensity,
      _period);
}

inline ActorExecutionConfigT *ActorExecutionConfig::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ActorExecutionConfigT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ActorExecutionConfig::UnPackTo(ActorExecutionConfigT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = task_prio(); _o->task_prio = _e; };
  { auto _e = task_stack_size(); _o->task_stack_size = _e; };
}

inline flatbuffers::Offset<ActorExecutionConfig> ActorExecutionConfig::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActorExecutionConfigT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateActorExecutionConfig(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ActorExecutionConfig> CreateActorExecutionConfig(flatbuffers::FlatBufferBuilder &_fbb, const ActorExecutionConfigT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ActorExecutionConfigT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _task_prio = _o->task_prio;
  auto _task_stack_size = _o->task_stack_size;
  return ActorModel::CreateActorExecutionConfig(
      _fbb,
      _task_prio,
      _task_stack_size);
}

inline bool VerifyResult(flatbuffers::Verifier &verifier, const void *obj, Result type) {
  switch (type) {
    case Result::NONE: {
      return true;
    }
    case Result::Ok: {
      auto ptr = reinterpret_cast<const Ok *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Result::Error: {
      auto ptr = reinterpret_cast<const Error *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyResultVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyResult(
        verifier,  values->Get(i), types->GetEnum<Result>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ResultUnion::UnPack(const void *obj, Result type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case Result::Ok: {
      auto ptr = reinterpret_cast<const Ok *>(obj);
      return ptr->UnPack(resolver);
    }
    case Result::Error: {
      auto ptr = reinterpret_cast<const Error *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> ResultUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case Result::Ok: {
      auto ptr = reinterpret_cast<const OkT *>(value);
      return CreateOk(_fbb, ptr, _rehasher).Union();
    }
    case Result::Error: {
      auto ptr = reinterpret_cast<const ErrorT *>(value);
      return CreateError(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ResultUnion::ResultUnion(const ResultUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case Result::Ok: {
      value = new OkT(*reinterpret_cast<OkT *>(u.value));
      break;
    }
    case Result::Error: {
      value = new ErrorT(*reinterpret_cast<ErrorT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ResultUnion::Reset() {
  switch (type) {
    case Result::Ok: {
      auto ptr = reinterpret_cast<OkT *>(value);
      delete ptr;
      break;
    }
    case Result::Error: {
      auto ptr = reinterpret_cast<ErrorT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Result::NONE;
}

inline flatbuffers::TypeTable *MessageTypeTable();

inline flatbuffers::TypeTable *OkTypeTable();

inline flatbuffers::TypeTable *ErrorTypeTable();

inline flatbuffers::TypeTable *SignalTypeTable();

inline flatbuffers::TypeTable *SupervisorFlagsTypeTable();

inline flatbuffers::TypeTable *ActorExecutionConfigTypeTable();

inline flatbuffers::TypeTable *SupervisionStrategyTypeTable() {
  static flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static flatbuffers::TypeFunction type_refs[] = {
    SupervisionStrategyTypeTable
  };
  static const char *names[] = {
    "one_for_one",
    "one_for_all",
    "rest_for_one",
    "simple_one_for_one"
  };
  static flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline flatbuffers::TypeTable *ProcessFlagTypeTable() {
  static flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SHORT, 0, 0 }
  };
  static flatbuffers::TypeFunction type_refs[] = {
    ProcessFlagTypeTable
  };
  static const char *names[] = {
    "trap_exit"
  };
  static flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 1, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline flatbuffers::TypeTable *ResultTypeTable() {
  static flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static flatbuffers::TypeFunction type_refs[] = {
    OkTypeTable,
    ErrorTypeTable
  };
  static const char *names[] = {
    "NONE",
    "Ok",
    "Error"
  };
  static flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline flatbuffers::TypeTable *MessageTypeTable() {
  static flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UCHAR, 1, -1 }
  };
  static flatbuffers::TypeFunction type_refs[] = {
    UUIDTypeTable
  };
  static const char *names[] = {
    "type",
    "timestamp",
    "from_pid",
    "payload_alignment",
    "payload"
  };
  static flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline flatbuffers::TypeTable *OkTypeTable() {
  static flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char *names[] = {
    "_"
  };
  static flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline flatbuffers::TypeTable *ErrorTypeTable() {
  static flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char *names[] = {
    "reason"
  };
  static flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline flatbuffers::TypeTable *SignalTypeTable() {
  static flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static flatbuffers::TypeFunction type_refs[] = {
    UUIDTypeTable
  };
  static const char *names[] = {
    "from_pid",
    "reason"
  };
  static flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline flatbuffers::TypeTable *SupervisorFlagsTypeTable() {
  static flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static flatbuffers::TypeFunction type_refs[] = {
    SupervisionStrategyTypeTable
  };
  static const char *names[] = {
    "strategy",
    "intensity",
    "period"
  };
  static flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline flatbuffers::TypeTable *ActorExecutionConfigTypeTable() {
  static flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 }
  };
  static const char *names[] = {
    "task_prio",
    "task_stack_size"
  };
  static flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const ActorModel::Message *GetMessage(const void *buf) {
  return flatbuffers::GetRoot<ActorModel::Message>(buf);
}

inline Message *GetMutableMessage(void *buf) {
  return flatbuffers::GetMutableRoot<Message>(buf);
}

inline const char *MessageIdentifier() {
  return "Act!";
}

inline bool MessageBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, MessageIdentifier());
}

inline bool VerifyMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ActorModel::Message>(MessageIdentifier());
}

inline void FinishMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ActorModel::Message> root) {
  fbb.Finish(root, MessageIdentifier());
}

inline std::unique_ptr<MessageT> UnPackMessage(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<MessageT>(GetMessage(buf)->UnPack(res));
}

}  // namespace ActorModel

#endif  // FLATBUFFERS_GENERATED_ACTORMODEL_ACTORMODEL_H_
