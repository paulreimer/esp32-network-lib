// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_REQUESTS_REQUESTS_H_
#define FLATBUFFERS_GENERATED_REQUESTS_REQUESTS_H_

#include "flatbuffers/flatbuffers.h"

#include "uuid_generated.h"

namespace Requests {

struct QueryPair;
struct QueryPairT;

struct HeaderPair;
struct HeaderPairT;

struct Request;
struct RequestT;

struct Response;
struct ResponseT;

struct RequestIntent;
struct RequestIntentT;

inline const flatbuffers::TypeTable *QueryPairTypeTable();

inline const flatbuffers::TypeTable *HeaderPairTypeTable();

inline const flatbuffers::TypeTable *RequestTypeTable();

inline const flatbuffers::TypeTable *ResponseTypeTable();

inline const flatbuffers::TypeTable *RequestIntentTypeTable();

enum class PostCallbackAction : int8_t {
  AbortProcessing = 0,
  ContinueProcessing = 1,
  MIN = AbortProcessing,
  MAX = ContinueProcessing
};

inline const PostCallbackAction (&EnumValuesPostCallbackAction())[2] {
  static const PostCallbackAction values[] = {
    PostCallbackAction::AbortProcessing,
    PostCallbackAction::ContinueProcessing
  };
  return values;
}

inline const char * const *EnumNamesPostCallbackAction() {
  static const char * const names[] = {
    "AbortProcessing",
    "ContinueProcessing",
    nullptr
  };
  return names;
}

inline const char *EnumNamePostCallbackAction(PostCallbackAction e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPostCallbackAction()[index];
}

enum class ResponseFilter : int16_t {
  FullResponseBody = 0,
  PartialResponseChunks = 1,
  JsonPath = 2,
  JsonPathAsFlatbuffers = 3,
  MIN = FullResponseBody,
  MAX = JsonPathAsFlatbuffers
};

inline const ResponseFilter (&EnumValuesResponseFilter())[4] {
  static const ResponseFilter values[] = {
    ResponseFilter::FullResponseBody,
    ResponseFilter::PartialResponseChunks,
    ResponseFilter::JsonPath,
    ResponseFilter::JsonPathAsFlatbuffers
  };
  return values;
}

inline const char * const *EnumNamesResponseFilter() {
  static const char * const names[] = {
    "FullResponseBody",
    "PartialResponseChunks",
    "JsonPath",
    "JsonPathAsFlatbuffers",
    nullptr
  };
  return names;
}

inline const char *EnumNameResponseFilter(ResponseFilter e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesResponseFilter()[index];
}

struct QueryPairT : public flatbuffers::NativeTable {
  typedef QueryPair TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "Requests.QueryPairT";
  }
  std::string k;
  std::string v;
  QueryPairT() {
  }
};

struct QueryPair FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QueryPairT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return QueryPairTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "Requests.QueryPair";
  }
  enum {
    VT_K = 4,
    VT_V = 6
  };
  const flatbuffers::String *k() const {
    return GetPointer<const flatbuffers::String *>(VT_K);
  }
  flatbuffers::String *mutable_k() {
    return GetPointer<flatbuffers::String *>(VT_K);
  }
  const flatbuffers::String *v() const {
    return GetPointer<const flatbuffers::String *>(VT_V);
  }
  flatbuffers::String *mutable_v() {
    return GetPointer<flatbuffers::String *>(VT_V);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_K) &&
           verifier.Verify(k()) &&
           VerifyOffset(verifier, VT_V) &&
           verifier.Verify(v()) &&
           verifier.EndTable();
  }
  QueryPairT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QueryPairT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<QueryPair> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QueryPairT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QueryPairBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_k(flatbuffers::Offset<flatbuffers::String> k) {
    fbb_.AddOffset(QueryPair::VT_K, k);
  }
  void add_v(flatbuffers::Offset<flatbuffers::String> v) {
    fbb_.AddOffset(QueryPair::VT_V, v);
  }
  explicit QueryPairBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QueryPairBuilder &operator=(const QueryPairBuilder &);
  flatbuffers::Offset<QueryPair> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QueryPair>(end);
    return o;
  }
};

inline flatbuffers::Offset<QueryPair> CreateQueryPair(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> k = 0,
    flatbuffers::Offset<flatbuffers::String> v = 0) {
  QueryPairBuilder builder_(_fbb);
  builder_.add_v(v);
  builder_.add_k(k);
  return builder_.Finish();
}

inline flatbuffers::Offset<QueryPair> CreateQueryPairDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *k = nullptr,
    const char *v = nullptr) {
  return Requests::CreateQueryPair(
      _fbb,
      k ? _fbb.CreateString(k) : 0,
      v ? _fbb.CreateString(v) : 0);
}

flatbuffers::Offset<QueryPair> CreateQueryPair(flatbuffers::FlatBufferBuilder &_fbb, const QueryPairT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HeaderPairT : public flatbuffers::NativeTable {
  typedef HeaderPair TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "Requests.HeaderPairT";
  }
  std::string k;
  std::string v;
  HeaderPairT() {
  }
};

struct HeaderPair FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HeaderPairT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return HeaderPairTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "Requests.HeaderPair";
  }
  enum {
    VT_K = 4,
    VT_V = 6
  };
  const flatbuffers::String *k() const {
    return GetPointer<const flatbuffers::String *>(VT_K);
  }
  flatbuffers::String *mutable_k() {
    return GetPointer<flatbuffers::String *>(VT_K);
  }
  const flatbuffers::String *v() const {
    return GetPointer<const flatbuffers::String *>(VT_V);
  }
  flatbuffers::String *mutable_v() {
    return GetPointer<flatbuffers::String *>(VT_V);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_K) &&
           verifier.Verify(k()) &&
           VerifyOffset(verifier, VT_V) &&
           verifier.Verify(v()) &&
           verifier.EndTable();
  }
  HeaderPairT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HeaderPairT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HeaderPair> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HeaderPairT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HeaderPairBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_k(flatbuffers::Offset<flatbuffers::String> k) {
    fbb_.AddOffset(HeaderPair::VT_K, k);
  }
  void add_v(flatbuffers::Offset<flatbuffers::String> v) {
    fbb_.AddOffset(HeaderPair::VT_V, v);
  }
  explicit HeaderPairBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HeaderPairBuilder &operator=(const HeaderPairBuilder &);
  flatbuffers::Offset<HeaderPair> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HeaderPair>(end);
    return o;
  }
};

inline flatbuffers::Offset<HeaderPair> CreateHeaderPair(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> k = 0,
    flatbuffers::Offset<flatbuffers::String> v = 0) {
  HeaderPairBuilder builder_(_fbb);
  builder_.add_v(v);
  builder_.add_k(k);
  return builder_.Finish();
}

inline flatbuffers::Offset<HeaderPair> CreateHeaderPairDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *k = nullptr,
    const char *v = nullptr) {
  return Requests::CreateHeaderPair(
      _fbb,
      k ? _fbb.CreateString(k) : 0,
      v ? _fbb.CreateString(v) : 0);
}

flatbuffers::Offset<HeaderPair> CreateHeaderPair(flatbuffers::FlatBufferBuilder &_fbb, const HeaderPairT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RequestT : public flatbuffers::NativeTable {
  typedef Request TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "Requests.RequestT";
  }
  std::string method;
  std::string uri;
  std::string body;
  std::vector<std::unique_ptr<QueryPairT>> query;
  std::vector<std::unique_ptr<HeaderPairT>> headers;
  RequestT() {
  }
};

struct Request FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RequestT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RequestTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "Requests.Request";
  }
  enum {
    VT_METHOD = 4,
    VT_URI = 6,
    VT_BODY = 8,
    VT_QUERY = 10,
    VT_HEADERS = 12
  };
  const flatbuffers::String *method() const {
    return GetPointer<const flatbuffers::String *>(VT_METHOD);
  }
  flatbuffers::String *mutable_method() {
    return GetPointer<flatbuffers::String *>(VT_METHOD);
  }
  const flatbuffers::String *uri() const {
    return GetPointer<const flatbuffers::String *>(VT_URI);
  }
  flatbuffers::String *mutable_uri() {
    return GetPointer<flatbuffers::String *>(VT_URI);
  }
  const flatbuffers::String *body() const {
    return GetPointer<const flatbuffers::String *>(VT_BODY);
  }
  flatbuffers::String *mutable_body() {
    return GetPointer<flatbuffers::String *>(VT_BODY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<QueryPair>> *query() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<QueryPair>> *>(VT_QUERY);
  }
  flatbuffers::Vector<flatbuffers::Offset<QueryPair>> *mutable_query() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<QueryPair>> *>(VT_QUERY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<HeaderPair>> *headers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<HeaderPair>> *>(VT_HEADERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<HeaderPair>> *mutable_headers() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<HeaderPair>> *>(VT_HEADERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_METHOD) &&
           verifier.Verify(method()) &&
           VerifyOffset(verifier, VT_URI) &&
           verifier.Verify(uri()) &&
           VerifyOffset(verifier, VT_BODY) &&
           verifier.Verify(body()) &&
           VerifyOffset(verifier, VT_QUERY) &&
           verifier.Verify(query()) &&
           verifier.VerifyVectorOfTables(query()) &&
           VerifyOffset(verifier, VT_HEADERS) &&
           verifier.Verify(headers()) &&
           verifier.VerifyVectorOfTables(headers()) &&
           verifier.EndTable();
  }
  RequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Request> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_method(flatbuffers::Offset<flatbuffers::String> method) {
    fbb_.AddOffset(Request::VT_METHOD, method);
  }
  void add_uri(flatbuffers::Offset<flatbuffers::String> uri) {
    fbb_.AddOffset(Request::VT_URI, uri);
  }
  void add_body(flatbuffers::Offset<flatbuffers::String> body) {
    fbb_.AddOffset(Request::VT_BODY, body);
  }
  void add_query(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<QueryPair>>> query) {
    fbb_.AddOffset(Request::VT_QUERY, query);
  }
  void add_headers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HeaderPair>>> headers) {
    fbb_.AddOffset(Request::VT_HEADERS, headers);
  }
  explicit RequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestBuilder &operator=(const RequestBuilder &);
  flatbuffers::Offset<Request> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Request>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request> CreateRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> method = 0,
    flatbuffers::Offset<flatbuffers::String> uri = 0,
    flatbuffers::Offset<flatbuffers::String> body = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<QueryPair>>> query = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HeaderPair>>> headers = 0) {
  RequestBuilder builder_(_fbb);
  builder_.add_headers(headers);
  builder_.add_query(query);
  builder_.add_body(body);
  builder_.add_uri(uri);
  builder_.add_method(method);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request> CreateRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *method = nullptr,
    const char *uri = nullptr,
    const char *body = nullptr,
    const std::vector<flatbuffers::Offset<QueryPair>> *query = nullptr,
    const std::vector<flatbuffers::Offset<HeaderPair>> *headers = nullptr) {
  return Requests::CreateRequest(
      _fbb,
      method ? _fbb.CreateString(method) : 0,
      uri ? _fbb.CreateString(uri) : 0,
      body ? _fbb.CreateString(body) : 0,
      query ? _fbb.CreateVector<flatbuffers::Offset<QueryPair>>(*query) : 0,
      headers ? _fbb.CreateVector<flatbuffers::Offset<HeaderPair>>(*headers) : 0);
}

flatbuffers::Offset<Request> CreateRequest(flatbuffers::FlatBufferBuilder &_fbb, const RequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResponseT : public flatbuffers::NativeTable {
  typedef Response TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "Requests.ResponseT";
  }
  int16_t code;
  std::vector<std::unique_ptr<HeaderPairT>> headers;
  std::string body;
  std::string errbuf;
  std::unique_ptr<UUID> request_id;
  ResponseT()
      : code(-1) {
  }
};

struct Response FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResponseT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ResponseTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "Requests.Response";
  }
  enum {
    VT_CODE = 4,
    VT_HEADERS = 6,
    VT_BODY = 8,
    VT_ERRBUF = 10,
    VT_REQUEST_ID = 12
  };
  int16_t code() const {
    return GetField<int16_t>(VT_CODE, -1);
  }
  bool mutate_code(int16_t _code) {
    return SetField<int16_t>(VT_CODE, _code, -1);
  }
  const flatbuffers::Vector<flatbuffers::Offset<HeaderPair>> *headers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<HeaderPair>> *>(VT_HEADERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<HeaderPair>> *mutable_headers() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<HeaderPair>> *>(VT_HEADERS);
  }
  const flatbuffers::String *body() const {
    return GetPointer<const flatbuffers::String *>(VT_BODY);
  }
  flatbuffers::String *mutable_body() {
    return GetPointer<flatbuffers::String *>(VT_BODY);
  }
  const flatbuffers::String *errbuf() const {
    return GetPointer<const flatbuffers::String *>(VT_ERRBUF);
  }
  flatbuffers::String *mutable_errbuf() {
    return GetPointer<flatbuffers::String *>(VT_ERRBUF);
  }
  const UUID *request_id() const {
    return GetStruct<const UUID *>(VT_REQUEST_ID);
  }
  UUID *mutable_request_id() {
    return GetStruct<UUID *>(VT_REQUEST_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_CODE) &&
           VerifyOffset(verifier, VT_HEADERS) &&
           verifier.Verify(headers()) &&
           verifier.VerifyVectorOfTables(headers()) &&
           VerifyOffset(verifier, VT_BODY) &&
           verifier.Verify(body()) &&
           VerifyOffset(verifier, VT_ERRBUF) &&
           verifier.Verify(errbuf()) &&
           VerifyField<UUID>(verifier, VT_REQUEST_ID) &&
           verifier.EndTable();
  }
  ResponseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResponseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Response> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(int16_t code) {
    fbb_.AddElement<int16_t>(Response::VT_CODE, code, -1);
  }
  void add_headers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HeaderPair>>> headers) {
    fbb_.AddOffset(Response::VT_HEADERS, headers);
  }
  void add_body(flatbuffers::Offset<flatbuffers::String> body) {
    fbb_.AddOffset(Response::VT_BODY, body);
  }
  void add_errbuf(flatbuffers::Offset<flatbuffers::String> errbuf) {
    fbb_.AddOffset(Response::VT_ERRBUF, errbuf);
  }
  void add_request_id(const UUID *request_id) {
    fbb_.AddStruct(Response::VT_REQUEST_ID, request_id);
  }
  explicit ResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResponseBuilder &operator=(const ResponseBuilder &);
  flatbuffers::Offset<Response> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Response>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response> CreateResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t code = -1,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HeaderPair>>> headers = 0,
    flatbuffers::Offset<flatbuffers::String> body = 0,
    flatbuffers::Offset<flatbuffers::String> errbuf = 0,
    const UUID *request_id = 0) {
  ResponseBuilder builder_(_fbb);
  builder_.add_request_id(request_id);
  builder_.add_errbuf(errbuf);
  builder_.add_body(body);
  builder_.add_headers(headers);
  builder_.add_code(code);
  return builder_.Finish();
}

inline flatbuffers::Offset<Response> CreateResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t code = -1,
    const std::vector<flatbuffers::Offset<HeaderPair>> *headers = nullptr,
    const char *body = nullptr,
    const char *errbuf = nullptr,
    const UUID *request_id = 0) {
  return Requests::CreateResponse(
      _fbb,
      code,
      headers ? _fbb.CreateVector<flatbuffers::Offset<HeaderPair>>(*headers) : 0,
      body ? _fbb.CreateString(body) : 0,
      errbuf ? _fbb.CreateString(errbuf) : 0,
      request_id);
}

flatbuffers::Offset<Response> CreateResponse(flatbuffers::FlatBufferBuilder &_fbb, const ResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RequestIntentT : public flatbuffers::NativeTable {
  typedef RequestIntent TableType;
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "Requests.RequestIntentT";
  }
  std::unique_ptr<UUID> id;
  std::unique_ptr<RequestT> request;
  std::unique_ptr<UUID> to_pid;
  ResponseFilter desired_format;
  std::string object_path;
  std::string root_type;
  std::string schema_text;
  bool include_headers;
  bool streaming;
  RequestIntentT()
      : desired_format(ResponseFilter::FullResponseBody),
        include_headers(false),
        streaming(false) {
  }
};

struct RequestIntent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RequestIntentT NativeTableType;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RequestIntentTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "Requests.RequestIntent";
  }
  enum {
    VT_ID = 4,
    VT_REQUEST = 6,
    VT_TO_PID = 8,
    VT_DESIRED_FORMAT = 10,
    VT_OBJECT_PATH = 12,
    VT_ROOT_TYPE = 14,
    VT_SCHEMA_TEXT = 16,
    VT_INCLUDE_HEADERS = 18,
    VT_STREAMING = 20
  };
  const UUID *id() const {
    return GetStruct<const UUID *>(VT_ID);
  }
  UUID *mutable_id() {
    return GetStruct<UUID *>(VT_ID);
  }
  const Request *request() const {
    return GetPointer<const Request *>(VT_REQUEST);
  }
  Request *mutable_request() {
    return GetPointer<Request *>(VT_REQUEST);
  }
  const UUID *to_pid() const {
    return GetStruct<const UUID *>(VT_TO_PID);
  }
  UUID *mutable_to_pid() {
    return GetStruct<UUID *>(VT_TO_PID);
  }
  ResponseFilter desired_format() const {
    return static_cast<ResponseFilter>(GetField<int16_t>(VT_DESIRED_FORMAT, 0));
  }
  bool mutate_desired_format(ResponseFilter _desired_format) {
    return SetField<int16_t>(VT_DESIRED_FORMAT, static_cast<int16_t>(_desired_format), 0);
  }
  const flatbuffers::String *object_path() const {
    return GetPointer<const flatbuffers::String *>(VT_OBJECT_PATH);
  }
  flatbuffers::String *mutable_object_path() {
    return GetPointer<flatbuffers::String *>(VT_OBJECT_PATH);
  }
  const flatbuffers::String *root_type() const {
    return GetPointer<const flatbuffers::String *>(VT_ROOT_TYPE);
  }
  flatbuffers::String *mutable_root_type() {
    return GetPointer<flatbuffers::String *>(VT_ROOT_TYPE);
  }
  const flatbuffers::String *schema_text() const {
    return GetPointer<const flatbuffers::String *>(VT_SCHEMA_TEXT);
  }
  flatbuffers::String *mutable_schema_text() {
    return GetPointer<flatbuffers::String *>(VT_SCHEMA_TEXT);
  }
  bool include_headers() const {
    return GetField<uint8_t>(VT_INCLUDE_HEADERS, 0) != 0;
  }
  bool mutate_include_headers(bool _include_headers) {
    return SetField<uint8_t>(VT_INCLUDE_HEADERS, static_cast<uint8_t>(_include_headers), 0);
  }
  bool streaming() const {
    return GetField<uint8_t>(VT_STREAMING, 0) != 0;
  }
  bool mutate_streaming(bool _streaming) {
    return SetField<uint8_t>(VT_STREAMING, static_cast<uint8_t>(_streaming), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<UUID>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_REQUEST) &&
           verifier.VerifyTable(request()) &&
           VerifyField<UUID>(verifier, VT_TO_PID) &&
           VerifyField<int16_t>(verifier, VT_DESIRED_FORMAT) &&
           VerifyOffset(verifier, VT_OBJECT_PATH) &&
           verifier.Verify(object_path()) &&
           VerifyOffset(verifier, VT_ROOT_TYPE) &&
           verifier.Verify(root_type()) &&
           VerifyOffset(verifier, VT_SCHEMA_TEXT) &&
           verifier.Verify(schema_text()) &&
           VerifyField<uint8_t>(verifier, VT_INCLUDE_HEADERS) &&
           VerifyField<uint8_t>(verifier, VT_STREAMING) &&
           verifier.EndTable();
  }
  RequestIntentT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RequestIntentT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RequestIntent> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RequestIntentT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RequestIntentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(const UUID *id) {
    fbb_.AddStruct(RequestIntent::VT_ID, id);
  }
  void add_request(flatbuffers::Offset<Request> request) {
    fbb_.AddOffset(RequestIntent::VT_REQUEST, request);
  }
  void add_to_pid(const UUID *to_pid) {
    fbb_.AddStruct(RequestIntent::VT_TO_PID, to_pid);
  }
  void add_desired_format(ResponseFilter desired_format) {
    fbb_.AddElement<int16_t>(RequestIntent::VT_DESIRED_FORMAT, static_cast<int16_t>(desired_format), 0);
  }
  void add_object_path(flatbuffers::Offset<flatbuffers::String> object_path) {
    fbb_.AddOffset(RequestIntent::VT_OBJECT_PATH, object_path);
  }
  void add_root_type(flatbuffers::Offset<flatbuffers::String> root_type) {
    fbb_.AddOffset(RequestIntent::VT_ROOT_TYPE, root_type);
  }
  void add_schema_text(flatbuffers::Offset<flatbuffers::String> schema_text) {
    fbb_.AddOffset(RequestIntent::VT_SCHEMA_TEXT, schema_text);
  }
  void add_include_headers(bool include_headers) {
    fbb_.AddElement<uint8_t>(RequestIntent::VT_INCLUDE_HEADERS, static_cast<uint8_t>(include_headers), 0);
  }
  void add_streaming(bool streaming) {
    fbb_.AddElement<uint8_t>(RequestIntent::VT_STREAMING, static_cast<uint8_t>(streaming), 0);
  }
  explicit RequestIntentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestIntentBuilder &operator=(const RequestIntentBuilder &);
  flatbuffers::Offset<RequestIntent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RequestIntent>(end);
    return o;
  }
};

inline flatbuffers::Offset<RequestIntent> CreateRequestIntent(
    flatbuffers::FlatBufferBuilder &_fbb,
    const UUID *id = 0,
    flatbuffers::Offset<Request> request = 0,
    const UUID *to_pid = 0,
    ResponseFilter desired_format = ResponseFilter::FullResponseBody,
    flatbuffers::Offset<flatbuffers::String> object_path = 0,
    flatbuffers::Offset<flatbuffers::String> root_type = 0,
    flatbuffers::Offset<flatbuffers::String> schema_text = 0,
    bool include_headers = false,
    bool streaming = false) {
  RequestIntentBuilder builder_(_fbb);
  builder_.add_schema_text(schema_text);
  builder_.add_root_type(root_type);
  builder_.add_object_path(object_path);
  builder_.add_to_pid(to_pid);
  builder_.add_request(request);
  builder_.add_id(id);
  builder_.add_desired_format(desired_format);
  builder_.add_streaming(streaming);
  builder_.add_include_headers(include_headers);
  return builder_.Finish();
}

inline flatbuffers::Offset<RequestIntent> CreateRequestIntentDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const UUID *id = 0,
    flatbuffers::Offset<Request> request = 0,
    const UUID *to_pid = 0,
    ResponseFilter desired_format = ResponseFilter::FullResponseBody,
    const char *object_path = nullptr,
    const char *root_type = nullptr,
    const char *schema_text = nullptr,
    bool include_headers = false,
    bool streaming = false) {
  return Requests::CreateRequestIntent(
      _fbb,
      id,
      request,
      to_pid,
      desired_format,
      object_path ? _fbb.CreateString(object_path) : 0,
      root_type ? _fbb.CreateString(root_type) : 0,
      schema_text ? _fbb.CreateString(schema_text) : 0,
      include_headers,
      streaming);
}

flatbuffers::Offset<RequestIntent> CreateRequestIntent(flatbuffers::FlatBufferBuilder &_fbb, const RequestIntentT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline QueryPairT *QueryPair::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new QueryPairT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void QueryPair::UnPackTo(QueryPairT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = k(); if (_e) _o->k = _e->str(); };
  { auto _e = v(); if (_e) _o->v = _e->str(); };
}

inline flatbuffers::Offset<QueryPair> QueryPair::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QueryPairT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQueryPair(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<QueryPair> CreateQueryPair(flatbuffers::FlatBufferBuilder &_fbb, const QueryPairT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const QueryPairT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _k = _o->k.empty() ? 0 : _fbb.CreateString(_o->k);
  auto _v = _o->v.empty() ? 0 : _fbb.CreateString(_o->v);
  return Requests::CreateQueryPair(
      _fbb,
      _k,
      _v);
}

inline HeaderPairT *HeaderPair::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HeaderPairT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HeaderPair::UnPackTo(HeaderPairT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = k(); if (_e) _o->k = _e->str(); };
  { auto _e = v(); if (_e) _o->v = _e->str(); };
}

inline flatbuffers::Offset<HeaderPair> HeaderPair::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HeaderPairT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHeaderPair(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HeaderPair> CreateHeaderPair(flatbuffers::FlatBufferBuilder &_fbb, const HeaderPairT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HeaderPairT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _k = _o->k.empty() ? 0 : _fbb.CreateString(_o->k);
  auto _v = _o->v.empty() ? 0 : _fbb.CreateString(_o->v);
  return Requests::CreateHeaderPair(
      _fbb,
      _k,
      _v);
}

inline RequestT *Request::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RequestT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Request::UnPackTo(RequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = method(); if (_e) _o->method = _e->str(); };
  { auto _e = uri(); if (_e) _o->uri = _e->str(); };
  { auto _e = body(); if (_e) _o->body = _e->str(); };
  { auto _e = query(); if (_e) { _o->query.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->query[_i] = std::unique_ptr<QueryPairT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = headers(); if (_e) { _o->headers.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->headers[_i] = std::unique_ptr<HeaderPairT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Request> Request::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Request> CreateRequest(flatbuffers::FlatBufferBuilder &_fbb, const RequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RequestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _method = _o->method.empty() ? 0 : _fbb.CreateString(_o->method);
  auto _uri = _o->uri.empty() ? 0 : _fbb.CreateString(_o->uri);
  auto _body = _o->body.empty() ? 0 : _fbb.CreateString(_o->body);
  auto _query = _o->query.size() ? _fbb.CreateVector<flatbuffers::Offset<QueryPair>> (_o->query.size(), [](size_t i, _VectorArgs *__va) { return CreateQueryPair(*__va->__fbb, __va->__o->query[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _headers = _o->headers.size() ? _fbb.CreateVector<flatbuffers::Offset<HeaderPair>> (_o->headers.size(), [](size_t i, _VectorArgs *__va) { return CreateHeaderPair(*__va->__fbb, __va->__o->headers[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Requests::CreateRequest(
      _fbb,
      _method,
      _uri,
      _body,
      _query,
      _headers);
}

inline ResponseT *Response::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ResponseT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Response::UnPackTo(ResponseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = code(); _o->code = _e; };
  { auto _e = headers(); if (_e) { _o->headers.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->headers[_i] = std::unique_ptr<HeaderPairT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = body(); if (_e) _o->body = _e->str(); };
  { auto _e = errbuf(); if (_e) _o->errbuf = _e->str(); };
  { auto _e = request_id(); if (_e) _o->request_id = std::unique_ptr<UUID>(new UUID(*_e)); };
}

inline flatbuffers::Offset<Response> Response::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResponseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResponse(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Response> CreateResponse(flatbuffers::FlatBufferBuilder &_fbb, const ResponseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ResponseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _code = _o->code;
  auto _headers = _o->headers.size() ? _fbb.CreateVector<flatbuffers::Offset<HeaderPair>> (_o->headers.size(), [](size_t i, _VectorArgs *__va) { return CreateHeaderPair(*__va->__fbb, __va->__o->headers[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _body = _o->body.empty() ? 0 : _fbb.CreateString(_o->body);
  auto _errbuf = _o->errbuf.empty() ? 0 : _fbb.CreateString(_o->errbuf);
  auto _request_id = _o->request_id ? _o->request_id.get() : 0;
  return Requests::CreateResponse(
      _fbb,
      _code,
      _headers,
      _body,
      _errbuf,
      _request_id);
}

inline RequestIntentT *RequestIntent::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RequestIntentT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RequestIntent::UnPackTo(RequestIntentT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = std::unique_ptr<UUID>(new UUID(*_e)); };
  { auto _e = request(); if (_e) _o->request = std::unique_ptr<RequestT>(_e->UnPack(_resolver)); };
  { auto _e = to_pid(); if (_e) _o->to_pid = std::unique_ptr<UUID>(new UUID(*_e)); };
  { auto _e = desired_format(); _o->desired_format = _e; };
  { auto _e = object_path(); if (_e) _o->object_path = _e->str(); };
  { auto _e = root_type(); if (_e) _o->root_type = _e->str(); };
  { auto _e = schema_text(); if (_e) _o->schema_text = _e->str(); };
  { auto _e = include_headers(); _o->include_headers = _e; };
  { auto _e = streaming(); _o->streaming = _e; };
}

inline flatbuffers::Offset<RequestIntent> RequestIntent::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RequestIntentT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequestIntent(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RequestIntent> CreateRequestIntent(flatbuffers::FlatBufferBuilder &_fbb, const RequestIntentT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RequestIntentT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id ? _o->id.get() : 0;
  auto _request = _o->request ? CreateRequest(_fbb, _o->request.get(), _rehasher) : 0;
  auto _to_pid = _o->to_pid ? _o->to_pid.get() : 0;
  auto _desired_format = _o->desired_format;
  auto _object_path = _o->object_path.empty() ? 0 : _fbb.CreateString(_o->object_path);
  auto _root_type = _o->root_type.empty() ? 0 : _fbb.CreateString(_o->root_type);
  auto _schema_text = _o->schema_text.empty() ? 0 : _fbb.CreateString(_o->schema_text);
  auto _include_headers = _o->include_headers;
  auto _streaming = _o->streaming;
  return Requests::CreateRequestIntent(
      _fbb,
      _id,
      _request,
      _to_pid,
      _desired_format,
      _object_path,
      _root_type,
      _schema_text,
      _include_headers,
      _streaming);
}

inline const flatbuffers::TypeTable *PostCallbackActionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PostCallbackActionTypeTable
  };
  static const char * const names[] = {
    "AbortProcessing",
    "ContinueProcessing"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ResponseFilterTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_SHORT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ResponseFilterTypeTable
  };
  static const char * const names[] = {
    "FullResponseBody",
    "PartialResponseChunks",
    "JsonPath",
    "JsonPathAsFlatbuffers"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *QueryPairTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "k",
    "v"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *HeaderPairTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "k",
    "v"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RequestTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    QueryPairTypeTable,
    HeaderPairTypeTable
  };
  static const char * const names[] = {
    "method",
    "uri",
    "body",
    "query",
    "headers"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ResponseTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SHORT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    HeaderPairTypeTable,
    UUIDTypeTable
  };
  static const char * const names[] = {
    "code",
    "headers",
    "body",
    "errbuf",
    "request_id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RequestIntentTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SHORT, 0, 2 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    UUIDTypeTable,
    RequestTypeTable,
    ResponseFilterTypeTable
  };
  static const char * const names[] = {
    "id",
    "request",
    "to_pid",
    "desired_format",
    "object_path",
    "root_type",
    "schema_text",
    "include_headers",
    "streaming"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 9, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const Requests::RequestIntent *GetRequestIntent(const void *buf) {
  return flatbuffers::GetRoot<Requests::RequestIntent>(buf);
}

inline const Requests::RequestIntent *GetSizePrefixedRequestIntent(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Requests::RequestIntent>(buf);
}

inline RequestIntent *GetMutableRequestIntent(void *buf) {
  return flatbuffers::GetMutableRoot<RequestIntent>(buf);
}

inline const char *RequestIntentIdentifier() {
  return "Req!";
}

inline bool RequestIntentBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, RequestIntentIdentifier());
}

inline bool VerifyRequestIntentBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Requests::RequestIntent>(RequestIntentIdentifier());
}

inline bool VerifySizePrefixedRequestIntentBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Requests::RequestIntent>(RequestIntentIdentifier());
}

inline const char *RequestIntentExtension() {
  return "fb";
}

inline void FinishRequestIntentBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Requests::RequestIntent> root) {
  fbb.Finish(root, RequestIntentIdentifier());
}

inline void FinishSizePrefixedRequestIntentBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Requests::RequestIntent> root) {
  fbb.FinishSizePrefixed(root, RequestIntentIdentifier());
}

inline std::unique_ptr<RequestIntentT> UnPackRequestIntent(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<RequestIntentT>(GetRequestIntent(buf)->UnPack(res));
}

}  // namespace Requests

#endif  // FLATBUFFERS_GENERATED_REQUESTS_REQUESTS_H_
