// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_REQUESTS_REQUESTS_H_
#define FLATBUFFERS_GENERATED_REQUESTS_REQUESTS_H_

#include "flatbuffers/flatbuffers.h"

#include "uuid_generated.h"

namespace Requests {

struct QueryPair;

struct HeaderPair;

struct Request;

struct Response;

struct RequestIntent;

inline const flatbuffers::TypeTable *QueryPairTypeTable();

inline const flatbuffers::TypeTable *HeaderPairTypeTable();

inline const flatbuffers::TypeTable *RequestTypeTable();

inline const flatbuffers::TypeTable *ResponseTypeTable();

inline const flatbuffers::TypeTable *RequestIntentTypeTable();

enum class PostCallbackAction : int8_t {
  AbortProcessing = 0,
  ContinueProcessing = 1,
  MIN = AbortProcessing,
  MAX = ContinueProcessing
};

inline const PostCallbackAction (&EnumValuesPostCallbackAction())[2] {
  static const PostCallbackAction values[] = {
    PostCallbackAction::AbortProcessing,
    PostCallbackAction::ContinueProcessing
  };
  return values;
}

inline const char * const *EnumNamesPostCallbackAction() {
  static const char * const names[] = {
    "AbortProcessing",
    "ContinueProcessing",
    nullptr
  };
  return names;
}

inline const char *EnumNamePostCallbackAction(PostCallbackAction e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPostCallbackAction()[index];
}

enum class ResponseFilter : int16_t {
  FullResponseBody = 0,
  PartialResponseChunks = 1,
  JsonPath = 2,
  JsonPathAsFlatbuffers = 3,
  MIN = FullResponseBody,
  MAX = JsonPathAsFlatbuffers
};

inline const ResponseFilter (&EnumValuesResponseFilter())[4] {
  static const ResponseFilter values[] = {
    ResponseFilter::FullResponseBody,
    ResponseFilter::PartialResponseChunks,
    ResponseFilter::JsonPath,
    ResponseFilter::JsonPathAsFlatbuffers
  };
  return values;
}

inline const char * const *EnumNamesResponseFilter() {
  static const char * const names[] = {
    "FullResponseBody",
    "PartialResponseChunks",
    "JsonPath",
    "JsonPathAsFlatbuffers",
    nullptr
  };
  return names;
}

inline const char *EnumNameResponseFilter(ResponseFilter e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesResponseFilter()[index];
}

struct QueryPair FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return QueryPairTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "Requests.QueryPair";
  }
  enum {
    VT_K = 4,
    VT_V = 6
  };
  const flatbuffers::String *k() const {
    return GetPointer<const flatbuffers::String *>(VT_K);
  }
  flatbuffers::String *mutable_k() {
    return GetPointer<flatbuffers::String *>(VT_K);
  }
  const flatbuffers::String *v() const {
    return GetPointer<const flatbuffers::String *>(VT_V);
  }
  flatbuffers::String *mutable_v() {
    return GetPointer<flatbuffers::String *>(VT_V);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_K) &&
           verifier.Verify(k()) &&
           VerifyOffset(verifier, VT_V) &&
           verifier.Verify(v()) &&
           verifier.EndTable();
  }
};

struct QueryPairBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_k(flatbuffers::Offset<flatbuffers::String> k) {
    fbb_.AddOffset(QueryPair::VT_K, k);
  }
  void add_v(flatbuffers::Offset<flatbuffers::String> v) {
    fbb_.AddOffset(QueryPair::VT_V, v);
  }
  explicit QueryPairBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QueryPairBuilder &operator=(const QueryPairBuilder &);
  flatbuffers::Offset<QueryPair> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QueryPair>(end);
    return o;
  }
};

inline flatbuffers::Offset<QueryPair> CreateQueryPair(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> k = 0,
    flatbuffers::Offset<flatbuffers::String> v = 0) {
  QueryPairBuilder builder_(_fbb);
  builder_.add_v(v);
  builder_.add_k(k);
  return builder_.Finish();
}

inline flatbuffers::Offset<QueryPair> CreateQueryPairDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *k = nullptr,
    const char *v = nullptr) {
  return Requests::CreateQueryPair(
      _fbb,
      k ? _fbb.CreateString(k) : 0,
      v ? _fbb.CreateString(v) : 0);
}

struct HeaderPair FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return HeaderPairTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "Requests.HeaderPair";
  }
  enum {
    VT_K = 4,
    VT_V = 6
  };
  const flatbuffers::String *k() const {
    return GetPointer<const flatbuffers::String *>(VT_K);
  }
  flatbuffers::String *mutable_k() {
    return GetPointer<flatbuffers::String *>(VT_K);
  }
  const flatbuffers::String *v() const {
    return GetPointer<const flatbuffers::String *>(VT_V);
  }
  flatbuffers::String *mutable_v() {
    return GetPointer<flatbuffers::String *>(VT_V);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_K) &&
           verifier.Verify(k()) &&
           VerifyOffset(verifier, VT_V) &&
           verifier.Verify(v()) &&
           verifier.EndTable();
  }
};

struct HeaderPairBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_k(flatbuffers::Offset<flatbuffers::String> k) {
    fbb_.AddOffset(HeaderPair::VT_K, k);
  }
  void add_v(flatbuffers::Offset<flatbuffers::String> v) {
    fbb_.AddOffset(HeaderPair::VT_V, v);
  }
  explicit HeaderPairBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HeaderPairBuilder &operator=(const HeaderPairBuilder &);
  flatbuffers::Offset<HeaderPair> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HeaderPair>(end);
    return o;
  }
};

inline flatbuffers::Offset<HeaderPair> CreateHeaderPair(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> k = 0,
    flatbuffers::Offset<flatbuffers::String> v = 0) {
  HeaderPairBuilder builder_(_fbb);
  builder_.add_v(v);
  builder_.add_k(k);
  return builder_.Finish();
}

inline flatbuffers::Offset<HeaderPair> CreateHeaderPairDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *k = nullptr,
    const char *v = nullptr) {
  return Requests::CreateHeaderPair(
      _fbb,
      k ? _fbb.CreateString(k) : 0,
      v ? _fbb.CreateString(v) : 0);
}

struct Request FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RequestTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "Requests.Request";
  }
  enum {
    VT_METHOD = 4,
    VT_URI = 6,
    VT_BODY = 8,
    VT_QUERY = 10,
    VT_HEADERS = 12
  };
  const flatbuffers::String *method() const {
    return GetPointer<const flatbuffers::String *>(VT_METHOD);
  }
  flatbuffers::String *mutable_method() {
    return GetPointer<flatbuffers::String *>(VT_METHOD);
  }
  const flatbuffers::String *uri() const {
    return GetPointer<const flatbuffers::String *>(VT_URI);
  }
  flatbuffers::String *mutable_uri() {
    return GetPointer<flatbuffers::String *>(VT_URI);
  }
  const flatbuffers::String *body() const {
    return GetPointer<const flatbuffers::String *>(VT_BODY);
  }
  flatbuffers::String *mutable_body() {
    return GetPointer<flatbuffers::String *>(VT_BODY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<QueryPair>> *query() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<QueryPair>> *>(VT_QUERY);
  }
  flatbuffers::Vector<flatbuffers::Offset<QueryPair>> *mutable_query() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<QueryPair>> *>(VT_QUERY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<HeaderPair>> *headers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<HeaderPair>> *>(VT_HEADERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<HeaderPair>> *mutable_headers() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<HeaderPair>> *>(VT_HEADERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_METHOD) &&
           verifier.Verify(method()) &&
           VerifyOffset(verifier, VT_URI) &&
           verifier.Verify(uri()) &&
           VerifyOffset(verifier, VT_BODY) &&
           verifier.Verify(body()) &&
           VerifyOffset(verifier, VT_QUERY) &&
           verifier.Verify(query()) &&
           verifier.VerifyVectorOfTables(query()) &&
           VerifyOffset(verifier, VT_HEADERS) &&
           verifier.Verify(headers()) &&
           verifier.VerifyVectorOfTables(headers()) &&
           verifier.EndTable();
  }
};

struct RequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_method(flatbuffers::Offset<flatbuffers::String> method) {
    fbb_.AddOffset(Request::VT_METHOD, method);
  }
  void add_uri(flatbuffers::Offset<flatbuffers::String> uri) {
    fbb_.AddOffset(Request::VT_URI, uri);
  }
  void add_body(flatbuffers::Offset<flatbuffers::String> body) {
    fbb_.AddOffset(Request::VT_BODY, body);
  }
  void add_query(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<QueryPair>>> query) {
    fbb_.AddOffset(Request::VT_QUERY, query);
  }
  void add_headers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HeaderPair>>> headers) {
    fbb_.AddOffset(Request::VT_HEADERS, headers);
  }
  explicit RequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestBuilder &operator=(const RequestBuilder &);
  flatbuffers::Offset<Request> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Request>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request> CreateRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> method = 0,
    flatbuffers::Offset<flatbuffers::String> uri = 0,
    flatbuffers::Offset<flatbuffers::String> body = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<QueryPair>>> query = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HeaderPair>>> headers = 0) {
  RequestBuilder builder_(_fbb);
  builder_.add_headers(headers);
  builder_.add_query(query);
  builder_.add_body(body);
  builder_.add_uri(uri);
  builder_.add_method(method);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request> CreateRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *method = nullptr,
    const char *uri = nullptr,
    const char *body = nullptr,
    const std::vector<flatbuffers::Offset<QueryPair>> *query = nullptr,
    const std::vector<flatbuffers::Offset<HeaderPair>> *headers = nullptr) {
  return Requests::CreateRequest(
      _fbb,
      method ? _fbb.CreateString(method) : 0,
      uri ? _fbb.CreateString(uri) : 0,
      body ? _fbb.CreateString(body) : 0,
      query ? _fbb.CreateVector<flatbuffers::Offset<QueryPair>>(*query) : 0,
      headers ? _fbb.CreateVector<flatbuffers::Offset<HeaderPair>>(*headers) : 0);
}

struct Response FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ResponseTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "Requests.Response";
  }
  enum {
    VT_CODE = 4,
    VT_HEADERS = 6,
    VT_BODY = 8,
    VT_ERRBUF = 10,
    VT_REQUEST_ID = 12
  };
  int16_t code() const {
    return GetField<int16_t>(VT_CODE, -1);
  }
  bool mutate_code(int16_t _code) {
    return SetField<int16_t>(VT_CODE, _code, -1);
  }
  const flatbuffers::Vector<flatbuffers::Offset<HeaderPair>> *headers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<HeaderPair>> *>(VT_HEADERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<HeaderPair>> *mutable_headers() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<HeaderPair>> *>(VT_HEADERS);
  }
  const flatbuffers::String *body() const {
    return GetPointer<const flatbuffers::String *>(VT_BODY);
  }
  flatbuffers::String *mutable_body() {
    return GetPointer<flatbuffers::String *>(VT_BODY);
  }
  const flatbuffers::String *errbuf() const {
    return GetPointer<const flatbuffers::String *>(VT_ERRBUF);
  }
  flatbuffers::String *mutable_errbuf() {
    return GetPointer<flatbuffers::String *>(VT_ERRBUF);
  }
  const UUID *request_id() const {
    return GetStruct<const UUID *>(VT_REQUEST_ID);
  }
  UUID *mutable_request_id() {
    return GetStruct<UUID *>(VT_REQUEST_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_CODE) &&
           VerifyOffset(verifier, VT_HEADERS) &&
           verifier.Verify(headers()) &&
           verifier.VerifyVectorOfTables(headers()) &&
           VerifyOffset(verifier, VT_BODY) &&
           verifier.Verify(body()) &&
           VerifyOffset(verifier, VT_ERRBUF) &&
           verifier.Verify(errbuf()) &&
           VerifyField<UUID>(verifier, VT_REQUEST_ID) &&
           verifier.EndTable();
  }
};

struct ResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(int16_t code) {
    fbb_.AddElement<int16_t>(Response::VT_CODE, code, -1);
  }
  void add_headers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HeaderPair>>> headers) {
    fbb_.AddOffset(Response::VT_HEADERS, headers);
  }
  void add_body(flatbuffers::Offset<flatbuffers::String> body) {
    fbb_.AddOffset(Response::VT_BODY, body);
  }
  void add_errbuf(flatbuffers::Offset<flatbuffers::String> errbuf) {
    fbb_.AddOffset(Response::VT_ERRBUF, errbuf);
  }
  void add_request_id(const UUID *request_id) {
    fbb_.AddStruct(Response::VT_REQUEST_ID, request_id);
  }
  explicit ResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResponseBuilder &operator=(const ResponseBuilder &);
  flatbuffers::Offset<Response> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Response>(end);
    return o;
  }
};

inline flatbuffers::Offset<Response> CreateResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t code = -1,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HeaderPair>>> headers = 0,
    flatbuffers::Offset<flatbuffers::String> body = 0,
    flatbuffers::Offset<flatbuffers::String> errbuf = 0,
    const UUID *request_id = 0) {
  ResponseBuilder builder_(_fbb);
  builder_.add_request_id(request_id);
  builder_.add_errbuf(errbuf);
  builder_.add_body(body);
  builder_.add_headers(headers);
  builder_.add_code(code);
  return builder_.Finish();
}

inline flatbuffers::Offset<Response> CreateResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t code = -1,
    const std::vector<flatbuffers::Offset<HeaderPair>> *headers = nullptr,
    const char *body = nullptr,
    const char *errbuf = nullptr,
    const UUID *request_id = 0) {
  return Requests::CreateResponse(
      _fbb,
      code,
      headers ? _fbb.CreateVector<flatbuffers::Offset<HeaderPair>>(*headers) : 0,
      body ? _fbb.CreateString(body) : 0,
      errbuf ? _fbb.CreateString(errbuf) : 0,
      request_id);
}

struct RequestIntent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return RequestIntentTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "Requests.RequestIntent";
  }
  enum {
    VT_ID = 4,
    VT_REQUEST = 6,
    VT_TO_PID = 8,
    VT_DESIRED_FORMAT = 10,
    VT_OBJECT_PATH = 12,
    VT_ROOT_TYPE = 14,
    VT_SCHEMA_TEXT = 16,
    VT_INCLUDE_HEADERS = 18,
    VT_STREAMING = 20
  };
  const UUID *id() const {
    return GetStruct<const UUID *>(VT_ID);
  }
  UUID *mutable_id() {
    return GetStruct<UUID *>(VT_ID);
  }
  const Request *request() const {
    return GetPointer<const Request *>(VT_REQUEST);
  }
  Request *mutable_request() {
    return GetPointer<Request *>(VT_REQUEST);
  }
  const UUID *to_pid() const {
    return GetStruct<const UUID *>(VT_TO_PID);
  }
  UUID *mutable_to_pid() {
    return GetStruct<UUID *>(VT_TO_PID);
  }
  ResponseFilter desired_format() const {
    return static_cast<ResponseFilter>(GetField<int16_t>(VT_DESIRED_FORMAT, 0));
  }
  bool mutate_desired_format(ResponseFilter _desired_format) {
    return SetField<int16_t>(VT_DESIRED_FORMAT, static_cast<int16_t>(_desired_format), 0);
  }
  const flatbuffers::String *object_path() const {
    return GetPointer<const flatbuffers::String *>(VT_OBJECT_PATH);
  }
  flatbuffers::String *mutable_object_path() {
    return GetPointer<flatbuffers::String *>(VT_OBJECT_PATH);
  }
  const flatbuffers::String *root_type() const {
    return GetPointer<const flatbuffers::String *>(VT_ROOT_TYPE);
  }
  flatbuffers::String *mutable_root_type() {
    return GetPointer<flatbuffers::String *>(VT_ROOT_TYPE);
  }
  const flatbuffers::String *schema_text() const {
    return GetPointer<const flatbuffers::String *>(VT_SCHEMA_TEXT);
  }
  flatbuffers::String *mutable_schema_text() {
    return GetPointer<flatbuffers::String *>(VT_SCHEMA_TEXT);
  }
  bool include_headers() const {
    return GetField<uint8_t>(VT_INCLUDE_HEADERS, 0) != 0;
  }
  bool mutate_include_headers(bool _include_headers) {
    return SetField<uint8_t>(VT_INCLUDE_HEADERS, static_cast<uint8_t>(_include_headers), 0);
  }
  bool streaming() const {
    return GetField<uint8_t>(VT_STREAMING, 0) != 0;
  }
  bool mutate_streaming(bool _streaming) {
    return SetField<uint8_t>(VT_STREAMING, static_cast<uint8_t>(_streaming), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<UUID>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_REQUEST) &&
           verifier.VerifyTable(request()) &&
           VerifyField<UUID>(verifier, VT_TO_PID) &&
           VerifyField<int16_t>(verifier, VT_DESIRED_FORMAT) &&
           VerifyOffset(verifier, VT_OBJECT_PATH) &&
           verifier.Verify(object_path()) &&
           VerifyOffset(verifier, VT_ROOT_TYPE) &&
           verifier.Verify(root_type()) &&
           VerifyOffset(verifier, VT_SCHEMA_TEXT) &&
           verifier.Verify(schema_text()) &&
           VerifyField<uint8_t>(verifier, VT_INCLUDE_HEADERS) &&
           VerifyField<uint8_t>(verifier, VT_STREAMING) &&
           verifier.EndTable();
  }
};

struct RequestIntentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(const UUID *id) {
    fbb_.AddStruct(RequestIntent::VT_ID, id);
  }
  void add_request(flatbuffers::Offset<Request> request) {
    fbb_.AddOffset(RequestIntent::VT_REQUEST, request);
  }
  void add_to_pid(const UUID *to_pid) {
    fbb_.AddStruct(RequestIntent::VT_TO_PID, to_pid);
  }
  void add_desired_format(ResponseFilter desired_format) {
    fbb_.AddElement<int16_t>(RequestIntent::VT_DESIRED_FORMAT, static_cast<int16_t>(desired_format), 0);
  }
  void add_object_path(flatbuffers::Offset<flatbuffers::String> object_path) {
    fbb_.AddOffset(RequestIntent::VT_OBJECT_PATH, object_path);
  }
  void add_root_type(flatbuffers::Offset<flatbuffers::String> root_type) {
    fbb_.AddOffset(RequestIntent::VT_ROOT_TYPE, root_type);
  }
  void add_schema_text(flatbuffers::Offset<flatbuffers::String> schema_text) {
    fbb_.AddOffset(RequestIntent::VT_SCHEMA_TEXT, schema_text);
  }
  void add_include_headers(bool include_headers) {
    fbb_.AddElement<uint8_t>(RequestIntent::VT_INCLUDE_HEADERS, static_cast<uint8_t>(include_headers), 0);
  }
  void add_streaming(bool streaming) {
    fbb_.AddElement<uint8_t>(RequestIntent::VT_STREAMING, static_cast<uint8_t>(streaming), 0);
  }
  explicit RequestIntentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestIntentBuilder &operator=(const RequestIntentBuilder &);
  flatbuffers::Offset<RequestIntent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RequestIntent>(end);
    return o;
  }
};

inline flatbuffers::Offset<RequestIntent> CreateRequestIntent(
    flatbuffers::FlatBufferBuilder &_fbb,
    const UUID *id = 0,
    flatbuffers::Offset<Request> request = 0,
    const UUID *to_pid = 0,
    ResponseFilter desired_format = ResponseFilter::FullResponseBody,
    flatbuffers::Offset<flatbuffers::String> object_path = 0,
    flatbuffers::Offset<flatbuffers::String> root_type = 0,
    flatbuffers::Offset<flatbuffers::String> schema_text = 0,
    bool include_headers = false,
    bool streaming = false) {
  RequestIntentBuilder builder_(_fbb);
  builder_.add_schema_text(schema_text);
  builder_.add_root_type(root_type);
  builder_.add_object_path(object_path);
  builder_.add_to_pid(to_pid);
  builder_.add_request(request);
  builder_.add_id(id);
  builder_.add_desired_format(desired_format);
  builder_.add_streaming(streaming);
  builder_.add_include_headers(include_headers);
  return builder_.Finish();
}

inline flatbuffers::Offset<RequestIntent> CreateRequestIntentDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const UUID *id = 0,
    flatbuffers::Offset<Request> request = 0,
    const UUID *to_pid = 0,
    ResponseFilter desired_format = ResponseFilter::FullResponseBody,
    const char *object_path = nullptr,
    const char *root_type = nullptr,
    const char *schema_text = nullptr,
    bool include_headers = false,
    bool streaming = false) {
  return Requests::CreateRequestIntent(
      _fbb,
      id,
      request,
      to_pid,
      desired_format,
      object_path ? _fbb.CreateString(object_path) : 0,
      root_type ? _fbb.CreateString(root_type) : 0,
      schema_text ? _fbb.CreateString(schema_text) : 0,
      include_headers,
      streaming);
}

inline const flatbuffers::TypeTable *PostCallbackActionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    PostCallbackActionTypeTable
  };
  static const char * const names[] = {
    "AbortProcessing",
    "ContinueProcessing"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ResponseFilterTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_SHORT, 0, 0 },
    { flatbuffers::ET_SHORT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    ResponseFilterTypeTable
  };
  static const char * const names[] = {
    "FullResponseBody",
    "PartialResponseChunks",
    "JsonPath",
    "JsonPathAsFlatbuffers"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *QueryPairTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "k",
    "v"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *HeaderPairTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "k",
    "v"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RequestTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    QueryPairTypeTable,
    HeaderPairTypeTable
  };
  static const char * const names[] = {
    "method",
    "uri",
    "body",
    "query",
    "headers"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ResponseTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SHORT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    HeaderPairTypeTable,
    UUIDTypeTable
  };
  static const char * const names[] = {
    "code",
    "headers",
    "body",
    "errbuf",
    "request_id"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *RequestIntentTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SHORT, 0, 2 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    UUIDTypeTable,
    RequestTypeTable,
    ResponseFilterTypeTable
  };
  static const char * const names[] = {
    "id",
    "request",
    "to_pid",
    "desired_format",
    "object_path",
    "root_type",
    "schema_text",
    "include_headers",
    "streaming"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 9, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const Requests::RequestIntent *GetRequestIntent(const void *buf) {
  return flatbuffers::GetRoot<Requests::RequestIntent>(buf);
}

inline const Requests::RequestIntent *GetSizePrefixedRequestIntent(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Requests::RequestIntent>(buf);
}

inline RequestIntent *GetMutableRequestIntent(void *buf) {
  return flatbuffers::GetMutableRoot<RequestIntent>(buf);
}

inline const char *RequestIntentIdentifier() {
  return "Req!";
}

inline bool RequestIntentBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, RequestIntentIdentifier());
}

inline bool VerifyRequestIntentBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Requests::RequestIntent>(RequestIntentIdentifier());
}

inline bool VerifySizePrefixedRequestIntentBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Requests::RequestIntent>(RequestIntentIdentifier());
}

inline const char *RequestIntentExtension() {
  return "fb";
}

inline void FinishRequestIntentBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Requests::RequestIntent> root) {
  fbb.Finish(root, RequestIntentIdentifier());
}

inline void FinishSizePrefixedRequestIntentBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Requests::RequestIntent> root) {
  fbb.FinishSizePrefixed(root, RequestIntentIdentifier());
}

}  // namespace Requests

#endif  // FLATBUFFERS_GENERATED_REQUESTS_REQUESTS_H_
