// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MQTT_MQTT_H_
#define FLATBUFFERS_GENERATED_MQTT_MQTT_H_

#include "flatbuffers/flatbuffers.h"

#include "uuid_generated.h"

namespace MQTT {

struct Subscription;

struct MQTTClientConfiguration;

struct MQTTMessage;

inline const flatbuffers::TypeTable *SubscriptionTypeTable();

inline const flatbuffers::TypeTable *MQTTClientConfigurationTypeTable();

inline const flatbuffers::TypeTable *MQTTMessageTypeTable();

enum class MQTT_QOS : int8_t {
  AtMostOnce = 0,
  AtLeastOnce = 1,
  ExactlyOnce = 2,
  MIN = AtMostOnce,
  MAX = ExactlyOnce
};

inline const MQTT_QOS (&EnumValuesMQTT_QOS())[3] {
  static const MQTT_QOS values[] = {
    MQTT_QOS::AtMostOnce,
    MQTT_QOS::AtLeastOnce,
    MQTT_QOS::ExactlyOnce
  };
  return values;
}

inline const char * const *EnumNamesMQTT_QOS() {
  static const char * const names[] = {
    "AtMostOnce",
    "AtLeastOnce",
    "ExactlyOnce",
    nullptr
  };
  return names;
}

inline const char *EnumNameMQTT_QOS(MQTT_QOS e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMQTT_QOS()[index];
}

struct Subscription FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SubscriptionTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "MQTT.Subscription";
  }
  enum {
    VT_TOPIC = 4
  };
  const flatbuffers::String *topic() const {
    return GetPointer<const flatbuffers::String *>(VT_TOPIC);
  }
  flatbuffers::String *mutable_topic() {
    return GetPointer<flatbuffers::String *>(VT_TOPIC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TOPIC) &&
           verifier.VerifyString(topic()) &&
           verifier.EndTable();
  }
};

struct SubscriptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_topic(flatbuffers::Offset<flatbuffers::String> topic) {
    fbb_.AddOffset(Subscription::VT_TOPIC, topic);
  }
  explicit SubscriptionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SubscriptionBuilder &operator=(const SubscriptionBuilder &);
  flatbuffers::Offset<Subscription> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Subscription>(end);
    return o;
  }
};

inline flatbuffers::Offset<Subscription> CreateSubscription(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> topic = 0) {
  SubscriptionBuilder builder_(_fbb);
  builder_.add_topic(topic);
  return builder_.Finish();
}

inline flatbuffers::Offset<Subscription> CreateSubscriptionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *topic = nullptr) {
  return MQTT::CreateSubscription(
      _fbb,
      topic ? _fbb.CreateString(topic) : 0);
}

struct MQTTClientConfiguration FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MQTTClientConfigurationTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "MQTT.MQTTClientConfiguration";
  }
  enum {
    VT_HOST = 4,
    VT_PORT = 6,
    VT_CLIENT_ID = 8,
    VT_CLIENT_USERNAME = 10,
    VT_CLIENT_PASSWORD = 12,
    VT_CLIENT_CERTIFICATE_PATH = 14,
    VT_CLIENT_PRIVATE_KEY_PATH = 16,
    VT_ROOT_CERTIFICATE_PATH = 18,
    VT_SUBSCRIPTIONS = 20
  };
  const flatbuffers::String *host() const {
    return GetPointer<const flatbuffers::String *>(VT_HOST);
  }
  flatbuffers::String *mutable_host() {
    return GetPointer<flatbuffers::String *>(VT_HOST);
  }
  uint16_t port() const {
    return GetField<uint16_t>(VT_PORT, 0);
  }
  bool mutate_port(uint16_t _port) {
    return SetField<uint16_t>(VT_PORT, _port, 0);
  }
  const flatbuffers::String *client_id() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENT_ID);
  }
  flatbuffers::String *mutable_client_id() {
    return GetPointer<flatbuffers::String *>(VT_CLIENT_ID);
  }
  const flatbuffers::String *client_username() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENT_USERNAME);
  }
  flatbuffers::String *mutable_client_username() {
    return GetPointer<flatbuffers::String *>(VT_CLIENT_USERNAME);
  }
  const flatbuffers::String *client_password() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENT_PASSWORD);
  }
  flatbuffers::String *mutable_client_password() {
    return GetPointer<flatbuffers::String *>(VT_CLIENT_PASSWORD);
  }
  const flatbuffers::String *client_certificate_path() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENT_CERTIFICATE_PATH);
  }
  flatbuffers::String *mutable_client_certificate_path() {
    return GetPointer<flatbuffers::String *>(VT_CLIENT_CERTIFICATE_PATH);
  }
  const flatbuffers::String *client_private_key_path() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENT_PRIVATE_KEY_PATH);
  }
  flatbuffers::String *mutable_client_private_key_path() {
    return GetPointer<flatbuffers::String *>(VT_CLIENT_PRIVATE_KEY_PATH);
  }
  const flatbuffers::String *root_certificate_path() const {
    return GetPointer<const flatbuffers::String *>(VT_ROOT_CERTIFICATE_PATH);
  }
  flatbuffers::String *mutable_root_certificate_path() {
    return GetPointer<flatbuffers::String *>(VT_ROOT_CERTIFICATE_PATH);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Subscription>> *subscriptions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Subscription>> *>(VT_SUBSCRIPTIONS);
  }
  flatbuffers::Vector<flatbuffers::Offset<Subscription>> *mutable_subscriptions() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Subscription>> *>(VT_SUBSCRIPTIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HOST) &&
           verifier.VerifyString(host()) &&
           VerifyField<uint16_t>(verifier, VT_PORT) &&
           VerifyOffset(verifier, VT_CLIENT_ID) &&
           verifier.VerifyString(client_id()) &&
           VerifyOffset(verifier, VT_CLIENT_USERNAME) &&
           verifier.VerifyString(client_username()) &&
           VerifyOffset(verifier, VT_CLIENT_PASSWORD) &&
           verifier.VerifyString(client_password()) &&
           VerifyOffset(verifier, VT_CLIENT_CERTIFICATE_PATH) &&
           verifier.VerifyString(client_certificate_path()) &&
           VerifyOffset(verifier, VT_CLIENT_PRIVATE_KEY_PATH) &&
           verifier.VerifyString(client_private_key_path()) &&
           VerifyOffset(verifier, VT_ROOT_CERTIFICATE_PATH) &&
           verifier.VerifyString(root_certificate_path()) &&
           VerifyOffset(verifier, VT_SUBSCRIPTIONS) &&
           verifier.VerifyVector(subscriptions()) &&
           verifier.VerifyVectorOfTables(subscriptions()) &&
           verifier.EndTable();
  }
};

struct MQTTClientConfigurationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_host(flatbuffers::Offset<flatbuffers::String> host) {
    fbb_.AddOffset(MQTTClientConfiguration::VT_HOST, host);
  }
  void add_port(uint16_t port) {
    fbb_.AddElement<uint16_t>(MQTTClientConfiguration::VT_PORT, port, 0);
  }
  void add_client_id(flatbuffers::Offset<flatbuffers::String> client_id) {
    fbb_.AddOffset(MQTTClientConfiguration::VT_CLIENT_ID, client_id);
  }
  void add_client_username(flatbuffers::Offset<flatbuffers::String> client_username) {
    fbb_.AddOffset(MQTTClientConfiguration::VT_CLIENT_USERNAME, client_username);
  }
  void add_client_password(flatbuffers::Offset<flatbuffers::String> client_password) {
    fbb_.AddOffset(MQTTClientConfiguration::VT_CLIENT_PASSWORD, client_password);
  }
  void add_client_certificate_path(flatbuffers::Offset<flatbuffers::String> client_certificate_path) {
    fbb_.AddOffset(MQTTClientConfiguration::VT_CLIENT_CERTIFICATE_PATH, client_certificate_path);
  }
  void add_client_private_key_path(flatbuffers::Offset<flatbuffers::String> client_private_key_path) {
    fbb_.AddOffset(MQTTClientConfiguration::VT_CLIENT_PRIVATE_KEY_PATH, client_private_key_path);
  }
  void add_root_certificate_path(flatbuffers::Offset<flatbuffers::String> root_certificate_path) {
    fbb_.AddOffset(MQTTClientConfiguration::VT_ROOT_CERTIFICATE_PATH, root_certificate_path);
  }
  void add_subscriptions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Subscription>>> subscriptions) {
    fbb_.AddOffset(MQTTClientConfiguration::VT_SUBSCRIPTIONS, subscriptions);
  }
  explicit MQTTClientConfigurationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MQTTClientConfigurationBuilder &operator=(const MQTTClientConfigurationBuilder &);
  flatbuffers::Offset<MQTTClientConfiguration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MQTTClientConfiguration>(end);
    return o;
  }
};

inline flatbuffers::Offset<MQTTClientConfiguration> CreateMQTTClientConfiguration(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> host = 0,
    uint16_t port = 0,
    flatbuffers::Offset<flatbuffers::String> client_id = 0,
    flatbuffers::Offset<flatbuffers::String> client_username = 0,
    flatbuffers::Offset<flatbuffers::String> client_password = 0,
    flatbuffers::Offset<flatbuffers::String> client_certificate_path = 0,
    flatbuffers::Offset<flatbuffers::String> client_private_key_path = 0,
    flatbuffers::Offset<flatbuffers::String> root_certificate_path = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Subscription>>> subscriptions = 0) {
  MQTTClientConfigurationBuilder builder_(_fbb);
  builder_.add_subscriptions(subscriptions);
  builder_.add_root_certificate_path(root_certificate_path);
  builder_.add_client_private_key_path(client_private_key_path);
  builder_.add_client_certificate_path(client_certificate_path);
  builder_.add_client_password(client_password);
  builder_.add_client_username(client_username);
  builder_.add_client_id(client_id);
  builder_.add_host(host);
  builder_.add_port(port);
  return builder_.Finish();
}

inline flatbuffers::Offset<MQTTClientConfiguration> CreateMQTTClientConfigurationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *host = nullptr,
    uint16_t port = 0,
    const char *client_id = nullptr,
    const char *client_username = nullptr,
    const char *client_password = nullptr,
    const char *client_certificate_path = nullptr,
    const char *client_private_key_path = nullptr,
    const char *root_certificate_path = nullptr,
    const std::vector<flatbuffers::Offset<Subscription>> *subscriptions = nullptr) {
  return MQTT::CreateMQTTClientConfiguration(
      _fbb,
      host ? _fbb.CreateString(host) : 0,
      port,
      client_id ? _fbb.CreateString(client_id) : 0,
      client_username ? _fbb.CreateString(client_username) : 0,
      client_password ? _fbb.CreateString(client_password) : 0,
      client_certificate_path ? _fbb.CreateString(client_certificate_path) : 0,
      client_private_key_path ? _fbb.CreateString(client_private_key_path) : 0,
      root_certificate_path ? _fbb.CreateString(root_certificate_path) : 0,
      subscriptions ? _fbb.CreateVector<flatbuffers::Offset<Subscription>>(*subscriptions) : 0);
}

struct MQTTMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return MQTTMessageTypeTable();
  }
  static FLATBUFFERS_CONSTEXPR const char *GetFullyQualifiedName() {
    return "MQTT.MQTTMessage";
  }
  enum {
    VT_TOPIC = 4,
    VT_PAYLOAD = 6,
    VT_QOS = 8,
    VT_RETAIN = 10
  };
  const flatbuffers::String *topic() const {
    return GetPointer<const flatbuffers::String *>(VT_TOPIC);
  }
  flatbuffers::String *mutable_topic() {
    return GetPointer<flatbuffers::String *>(VT_TOPIC);
  }
  const flatbuffers::String *payload() const {
    return GetPointer<const flatbuffers::String *>(VT_PAYLOAD);
  }
  flatbuffers::String *mutable_payload() {
    return GetPointer<flatbuffers::String *>(VT_PAYLOAD);
  }
  MQTT_QOS qos() const {
    return static_cast<MQTT_QOS>(GetField<int8_t>(VT_QOS, 0));
  }
  bool mutate_qos(MQTT_QOS _qos) {
    return SetField<int8_t>(VT_QOS, static_cast<int8_t>(_qos), 0);
  }
  bool retain() const {
    return GetField<uint8_t>(VT_RETAIN, 0) != 0;
  }
  bool mutate_retain(bool _retain) {
    return SetField<uint8_t>(VT_RETAIN, static_cast<uint8_t>(_retain), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TOPIC) &&
           verifier.VerifyString(topic()) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           verifier.VerifyString(payload()) &&
           VerifyField<int8_t>(verifier, VT_QOS) &&
           VerifyField<uint8_t>(verifier, VT_RETAIN) &&
           verifier.EndTable();
  }
};

struct MQTTMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_topic(flatbuffers::Offset<flatbuffers::String> topic) {
    fbb_.AddOffset(MQTTMessage::VT_TOPIC, topic);
  }
  void add_payload(flatbuffers::Offset<flatbuffers::String> payload) {
    fbb_.AddOffset(MQTTMessage::VT_PAYLOAD, payload);
  }
  void add_qos(MQTT_QOS qos) {
    fbb_.AddElement<int8_t>(MQTTMessage::VT_QOS, static_cast<int8_t>(qos), 0);
  }
  void add_retain(bool retain) {
    fbb_.AddElement<uint8_t>(MQTTMessage::VT_RETAIN, static_cast<uint8_t>(retain), 0);
  }
  explicit MQTTMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MQTTMessageBuilder &operator=(const MQTTMessageBuilder &);
  flatbuffers::Offset<MQTTMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MQTTMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<MQTTMessage> CreateMQTTMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> topic = 0,
    flatbuffers::Offset<flatbuffers::String> payload = 0,
    MQTT_QOS qos = MQTT_QOS::AtMostOnce,
    bool retain = false) {
  MQTTMessageBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_topic(topic);
  builder_.add_retain(retain);
  builder_.add_qos(qos);
  return builder_.Finish();
}

inline flatbuffers::Offset<MQTTMessage> CreateMQTTMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *topic = nullptr,
    const char *payload = nullptr,
    MQTT_QOS qos = MQTT_QOS::AtMostOnce,
    bool retain = false) {
  return MQTT::CreateMQTTMessage(
      _fbb,
      topic ? _fbb.CreateString(topic) : 0,
      payload ? _fbb.CreateString(payload) : 0,
      qos,
      retain);
}

inline const flatbuffers::TypeTable *MQTT_QOSTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    MQTT_QOSTypeTable
  };
  static const char * const names[] = {
    "AtMostOnce",
    "AtLeastOnce",
    "ExactlyOnce"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SubscriptionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const char * const names[] = {
    "topic"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 1, type_codes, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MQTTClientConfigurationTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    SubscriptionTypeTable
  };
  static const char * const names[] = {
    "host",
    "port",
    "client_id",
    "client_username",
    "client_password",
    "client_certificate_path",
    "client_private_key_path",
    "root_certificate_path",
    "subscriptions"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 9, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MQTTMessageTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    MQTT_QOSTypeTable
  };
  static const char * const names[] = {
    "topic",
    "payload",
    "qos",
    "retain"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, names
  };
  return &tt;
}

inline const MQTT::MQTTClientConfiguration *GetMQTTClientConfiguration(const void *buf) {
  return flatbuffers::GetRoot<MQTT::MQTTClientConfiguration>(buf);
}

inline const MQTT::MQTTClientConfiguration *GetSizePrefixedMQTTClientConfiguration(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<MQTT::MQTTClientConfiguration>(buf);
}

inline MQTTClientConfiguration *GetMutableMQTTClientConfiguration(void *buf) {
  return flatbuffers::GetMutableRoot<MQTTClientConfiguration>(buf);
}

inline const char *MQTTClientConfigurationIdentifier() {
  return "mqtt";
}

inline bool MQTTClientConfigurationBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, MQTTClientConfigurationIdentifier());
}

inline bool VerifyMQTTClientConfigurationBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MQTT::MQTTClientConfiguration>(MQTTClientConfigurationIdentifier());
}

inline bool VerifySizePrefixedMQTTClientConfigurationBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<MQTT::MQTTClientConfiguration>(MQTTClientConfigurationIdentifier());
}

inline const char *MQTTClientConfigurationExtension() {
  return "fb";
}

inline void FinishMQTTClientConfigurationBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<MQTT::MQTTClientConfiguration> root) {
  fbb.Finish(root, MQTTClientConfigurationIdentifier());
}

inline void FinishSizePrefixedMQTTClientConfigurationBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<MQTT::MQTTClientConfiguration> root) {
  fbb.FinishSizePrefixed(root, MQTTClientConfigurationIdentifier());
}

}  // namespace MQTT

#endif  // FLATBUFFERS_GENERATED_MQTT_MQTT_H_
